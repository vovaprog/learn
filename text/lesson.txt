+ Список контейнеров STL
+ Алгоритмическая сложность контейнеров STL
+ smart pointers
+ special member functions
+ c++11 threads
+ Copy-and-swap
+ sockets
+ tcp/ip levels
+ исключения
+ undefined/unspecified behavior
+ Singleton c++ realization
+ характеристики сортировок
+ c++11 new features
+ ООП
+ remove-erase

+ priority_queue
+ Преобразования типов
+ RTTI
+ size_t
+ default, delete functions
+ move semantics
+ function call resolution
+ traits
+ multimap/multiset
+ priority_queue
+ const pointer and pointer to const
+ posix processes
+ posix threads
+ posix ipc
+ stl and thread safety
+ c++11 futures
+ raw sockets
+ poll/select
+ nothrow new, placement new
+ virtual destructor
+ Почему константы объявляют как enum?
+ non type template parameters

+ template<typename> vs template<class>
+ точки следования (sequence points)
+ Типы наследования
+ паттерны проектирования
+ сложность вставки в vector - вывод формулы

+ свертка ссылок (reference collapsing rules)
deadlocks
+ вызываются ли конструкторы-присваивания при работе с vector и т.п. (да, вызываются)
copy elision
+ static_assert
+ thread_local

шаблоны
Trie

call convention
constexpr c++11
unicode

//------------
+ nothrow new
+ placement new
+ исключения
+ порядок catch блоков
+ как ловить по значению или по ссылке (по ссылке)
+ где лежит объект исключения
+ внутреннее устройство исключений
+ undefined/unspecified behavior
+ none type template parameters (int double какие допустимы)
+ виртуальный деструктор
+ Copy-and-swap
+ smart pointers (где лежит указатель на объект в control block или в самом объекте, какие операции потоко безопасны)
+ make_shared
+ weak_ptr
+ статический полиморфизм
+ сложность вставки в vector - вывод формулы
+ характеристики сортировок

cast
исключение в деструкторе
Майерс исключения
вызов виртуальной функции в списке инициализации
сложность stable_sort
facebook контейнеры
типы контейнеров stl
deque - сложность операций
типы хеш таблиц
insert sort
когда создается move конструктор
правила создания стандартных функций класса
шаблоны
перевернуть односвязный список
cracking the coding interview
producer-consumer
//------------


//--------------------------
из db:
Пример starvation
explicit конструкторы когда вызываются
signal sig_pipe при работе с сокетами
реализация singleton

//--------------------------



//============================================================================
Список контейнеров STL
//============================================================================

Sequence containers (Последовательные контейнеры)
vector
deque
list
array 
forward_list

Associative containers
set
map
multiset
multimap

Unordered associative containers
unordered_set
unordered_map
unordered_multiset
unordered_multimap

Container adaptors
stack
queue
priority_queue


//============================================================================    
Алгоритмическая сложность контейнеров STL    
//============================================================================

http://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html    


//============================================================================
+ c++11 new features
//============================================================================

threads
unordered assoc container
lambda
range based loop
enum class
auto
shared_ptr, unique_ptr
nullptr


//============================================================================
smart pointers
//============================================================================

weak_ptr - метод lock() возвращает shared_ptr на указываемый объект.
Если объект уже удален, то возращается default constructed shared_ptr.
Есть метод expired() - проверить, что объект удален.

В shared_ptr может исползоваться deleter - функтор объект для удаления указателя.

__shared_ptr{
      _Tp*	   	   _M_ptr;         // Contained pointer.
      __shared_count<_Lp>  _M_refcount;    // Reference counter.
};

__shared_count{
    _Sp_counted_base<_Lp>*  _M_pi;
};

_Sp_counted_base{
      _Atomic_word  _M_use_count;     // #shared
      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)
}

_Sp_counted_deleter:_Sp_counted_base
{
      _Ptr             _M_ptr;  // copy constructor must not throw
      _My_Deleter      _M_del;  // copy constructor must not throw
};

!!! It is only the control block itself which is thread-safe.

//Реализация reset g++:
void reset() noexcept
{ 
    __shared_ptr().swap(*this); 
}

template<typename _Tp1>
void reset(_Tp1* __p) // _Tp1 must be complete.
{
  __shared_ptr(__p).swap(*this);
}

Т.е reset меняет только определенный объект shared_ptr,
в control_block, на который раньше указывал shared_ptr уменьшается счетчик ссылок.
Все объекты которые работали с прежним указателем будут работать с ним дальше.
Т.е. reset нельзя вызывать на одном и том же объекте shared_ptr из разных потоков, но можно вызывать на разных объектах shared_ptr. 

Можно в разных потоках создавать и удалять shared_ptr.
Нельзя вызывать методы (reset) на одном объекте shared_ptr из разных потоков.
Нельзя вызывать изменяющие методы на самих данных, с которыми работает shared_ptr.

make_shared:

fun(std::make_shared<Lhs>("foo"), std::make_shared<Rhs>("bar"));

std::make_shared performs one heap-allocation, whereas calling the std::shared_ptr constructor performs two.
std::make_shared performs a single heap-allocation accounting for the space necessary for both the control block and the data. 
In the other case, new Obj("foo") invokes a heap-allocation for the managed data and the std::shared_ptr constructor performs another one for the control block.

Disadvantage of make_shared: 
Since there there's only one allocation, the pointee's memory cannot be deallocated until the control block is no longer in use. A weak_ptr can keep the control block alive indefinitely.


//============================================================================
special member functions
//============================================================================
Special member functions in C++ are functions which the compiler will automatically generate if they are used, but not declared explicitly by the programmer.

C++ has six kinds of special member functions:
*Default constructors   ( if no other constructor is explicitly declared )
*Destructors
*Copy constructors          (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy constructor is deprecated)
*Copy assignment operators  (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy assignment operator is deprecated.) 
*Move constructors          (if no copy constructor, copy assignment operator, move assignment operator and destructor are explicitly declared.)
*Move assignment operators  (if no copy constructor, copy assignment operator, move constructor and destructor are explicitly declared.)

Signatures:
Default constructor 	MyClass();
Copy constructor 	MyClass(const MyClass& other);
Move constructor 	MyClass(MyClass&& other) noexcept;
Copy assignment operator 	MyClass& operator=(const MyClass& other);
Move assignment operator 	MyClass& operator=(MyClass&& other) noexcept;
Destructor 	~MyClass();


Default constructor:      no other constructor is explicitly declared
Destructor
Copy constructor:         no move constructor 
                          no move assignment operator
                          If a destructor is declared generation of a copy constructor is deprecated (C++11)
Copy assignment operator: no move constructor 
                          no move assignment operator are explicitly declared.
                          If a destructor is declared generation of a copy assignment operator is deprecated.                                             
Move constructor:         no copy constructor 
                          no copy assignment operator
                          no move assignment operator 
                          no destructor                      
Move assignment operator: no copy constructor
                          no copy assignment operator
                          no move constructor 
                          no destructor

                          
//============================================================================
C++ 11 threads
//============================================================================

http://en.cppreference.com/w/cpp/thread

thread
mutex
condition_variable
futures

//-----------------------------------------------------------------

mutex:
mutex
timed_mutex
recursive_mutex
recursive_timed_mutex
shared_mutex (c++17)
shared_timed_mutex (c++14)

mutex methods:
lock, try_lock, unlock

shared_mutex (shared_mutex has two levels of access:
    shared - several threads can share ownership of the same mutex. 
    exclusive - only one thread can own the mutex. (one writer - multiple readers)):
lock, try_lock, unlock
lock_shared, try_lock_shared, unlock_shared


scope locks:
lock_guard
unique_lock
shared_lock

{
    std::lock_guard<std::mutex> lock(g_i_mutex);
}    

lock, try_lock - lock algorithms, avoid deadlocks.
std::lock(e1.m, e2.m);
std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);
std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);


Difference lock_guard - unique_lock:
The difference is that you can lock and unlock a std::unique_lock. std::lock_guard will be locked only once on construction and unlocked on destruction.


call_once - Executes the Callable object f exactly once, even if called from several threads. 


//-----------------------------------------------------------------

conditional_variable:

void ThreadPool::runTask(ThreadFunction fun, void *userData)
{
    {
        unique_lock<mutex> lock(mutexTasks);
    
        tasks.push(ThreadPoolTask(fun,userData));
    }

    cvTasks.notify_one();
}
...........................

{
    unique_lock<mutex> lock(mutexTasks);

    //проверка делается под mutex-ом, так что не может быть такого, что
    //проверили условие, потом оно изменилось, а мы попали в wait
    while(tasks.empty())
    {
        cvTasks.wait(lock);                
    }
}

std::condition_variable works only with std::unique_lock<std::mutex>
std::condition_variable_any provides a condition variable that works with any BasicLockable object. 

notify_all_at_thread_exit provides a mechanism to notify other threads that a given thread has completely finished:
void notify_all_at_thread_exit( std::condition_variable& cond,
                                std::unique_lock<std::mutex> lk );
            
Do I have to aquire lock before calling condition_variable.notify_one()?
You do not need to be holding a lock when calling condition_variable::notify_one(), 
but it's not wrong in the sense that it's still well defined behavior and not an error.
However, it might be a "pessimization" since whatever waiting thread is made runnable (if any) 
will immediately try to acquire the lock that the notifying thread holds.
                                
//-----------------------------------------------------------------
           

//============================================================================
Copy and swap
//============================================================================

The copy-and-swap idiom is the solution, 
and elegantly assists the assignment operator in achieving two things: 
avoiding code duplication, and providing a strong exception guarantee.

it works by using the copy-constructor's functionality to create a local copy of the data, 
then takes the copied data with a swap function, swapping the old data with the new data. 
The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.

In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, 
a working destructor (both are the basis of any wrapper, so should be complete anyway), and a non-throwing swap function.

Нельзя использовать std::swap, т.к. он использует  copy-constructor and copy-assignment operator,
нужно написать свой swap.

class dumb_array{
public:
    friend void swap(dumb_array& first, dumb_array& second) // nothrow
    {
        using std::swap;
        swap(first.mSize, second.mSize);
        swap(first.mArray, second.mArray);
    }
};
dumb_array& operator=(dumb_array other) // (1)
{
    swap(*this, other); // (2)

    return *this;
}


//move constructor (не обязательно, просто пример):
    dumb_array(dumb_array&& other)
        : dumb_array() // initialize via default constructor, C++11 only
    {
        swap(*this, other);
    }
if other is being initialized with an rvalue, it will be move-constructed.     


//============================================================================
sockets
//============================================================================

Вызовы клиент:
socket
gethostbyname или getaddrinfo
connect
send / write
recv / read
close

Вызовы сервер:
socket
bind //связывает сокет с конкретным адресом. Когда сокет создается при помощи socket(), он ассоциируется с некоторым семейством адресов, но не с конкретным адресом.
listen
while
{
    client_socket = accept
    recv
    send
    close
}
close


udp socket client:
socket
gethostbyname
while
{
    sendto
    recvfrom
}
close

udp socket server:
socket
bind
while
{
    recvfrom //returns client address
    sendto   //we can send back to client address
}    
close

                         
//============================================================================
tcp/ip levels
//============================================================================

Application layer (Прикладной)     HTTP, RTSP, FTP, DNS
Transport layer   (Транспортный)   TCP, UDP
Internet layer    (Сетевой)        IP, ICMP
Link layer        (Канальный)      Ethernet, Wifi


Сетевая модель OSI (open systems interconnection basic reference model):
----- Host layers -----
Прикладной (application)
Представительский (представления) (presentation)
Сеансовый (session)
Транспортный (transport)

----- Media Layers -----
Сетевой (network)
Канальный (data link)
Физический (physical)


Tcp/Ip - OSI - соответствие:
TCP/IP        OSI

Application - application, presentation, session
transport   - transport
network     - network
Link layer  - link, physical


//============================================================================
tcp
//============================================================================

Установка соединения:
Сервер шлет syn
Клиент шлет syn ack
Сервер шлет ack

Разрыв соединения:
1 сторона FIN
2 сторона ACK
2 сторона FIN
1 сторона ACK

Разрыв соединения:
1 сторона FIN
2 сторона FIN ACK 
1 сторона ACK

В каждом пакете Sequence Number
Acknowledgement Number - если установлен флаг ack.

Изначально Sequence Number с обоих сторон устанавливается в случайное число.

Sequence Number - стартовое значение seqnum + количество байт, которые отправлены перед текущим пакетом.
Sequence Number - accumulated sequence number of the first data byte of this segment for the current session
Acknowledgement Number - if the ACK flag is set then the value of this field is the next sequence number that the receiver is expecting.

//============================================================================
Exceptions
//============================================================================

The standard practice for exceptions in C++ is
Throw by value, catch by reference

If the stack unwinds completely without finding a suitable catch block, the standard function terminate is called.
You can install your own handler that terminates exception processing by calling set_terminate

An exception specification  - They are now deprecated in C++
An exception specification is a guarantee to the caller of a function that only certain exceptions will be thrown within it.
void fetch(char *name, char *&data) throw (BadFileName, HandlesGone);
If the function throws an exception of a type not listed in the exception specification, 
or of a type not derived from one of the listed types, the standard function std::unexpected is called. 
The default behavior for this function is to terminate the program.
You can install your own handler for this by calling set_unexpected

class exception;
Standard exception class
Base class for standard exceptions.
All objects thrown by components of the standard library are derived from this class. 
Therefore, all standard exceptions can be caught by catching this type by reference.
virtual const char* what() const throw();

Если ловить по значению, то catch(BaseClass ex) поймает и ChildClass,
но класс при этом преобразуется в BaseClass.
Если ловить по ссылке, то можно ловить полиморфно:
catch(BaseClass &ex) поймает ChildClass и ex будет привязана к объекту ребенка.

Неправильный порядок catch - сначала базовый, потом ребенок.
g++ выдает сообщение:
warning: exception of type ‘MyExceptionB’ will be caught by earlier handler for ‘MyExceptionA’,
но код нормально компилирует.
catch(...) может быть только последним, иначе ошибка:
error: ‘...’ handler must be the last handler for its try block

//размещение объекта исключения:
most implementations seem to allocate memory on a local thread storage (heap) 
but resort to an emergency storage (presumably static) if out of memory. 

https://monoinfinito.wordpress.com/series/exception-handling-in-c/
http://mentorembedded.github.io/cxx-abi/
http://www.logix.cz/michal/devel/gas-cfi/


throw 1; //базовые типы:
при catch базовых типов преобразование не производится.
тип исключения в catch должен точно соответствовать типу бросаемого исключения.


noexcept
http://en.cppreference.com/w/cpp/language/noexcept_spec

If a search for a matching exception handler leaves a function marked noexcept or noexcept(true), std::terminate is called immediately.
In C++ 11 if destructor has no exception specifiers it is noexcept.
So throwing from destructor in C++ 11 will terminate program.

Before c++ 11 terminate is called only if exception is thrown during stack unwinding.



//============================================================================
undefined/unspecified behavior
//============================================================================

undefined behaviour - неправильное использование программы - например,
обращение за границы массива.

unspecified behaviour - скорее всего все в порядке, но что точно сделает
программа - не известно. Например:
f(foo(), bar());
Неизвестно, что будет вызвано раньше - foo или bar.

Unspecified behavior
Система может реализовать любое из поведений
и не должна говорить какое именно реализовано и даже не обязательно, 
чтобы она вела себя в таких ситуациях одинаково внутри одной программы или функции.
unspecified behavior означает "как будет работать толком неизвестно, но все будет хорошо".
Программа, в которой есть unspecified behavior - правильная программа.
Пример - порядок вычисления аргументов функции.

Undefined behavior
поведение может возникать только как реакция на неправильную программу.
Undefined behavior означает, что стандарт не накладывает каких-либо ограничений. 
Может случиться все, что угодно.
Пример - разыменование указателя, который равен NULL, может дать 0, 
или любое произвольное значение, или остановку программы, 
или сигнал какого-либо вида, или исключение.


//============================================================================
Singleton realization
//============================================================================
    
class S
{
    public:
        static S& getInstance()
        {
            static S    instance; // Guaranteed to be destroyed. Instantiated on first use. 
            return instance;
        }
    private:
        S() {};                   // Constructor? (the {} brackets) are needed here.
        // C++ 03
        // ========
        // Dont forget to declare these two. You want to make sure they
        // are unacceptable otherwise you may accidentally get copies of
        // your singleton appearing.
        S(S const&);              // Don't Implement
        void operator=(S const&); // Don't implement

        // C++ 11
        // =======
        // We can use the better technique of deleting the methods
        // we don't want.
    public:
        S(S const&)               = delete;
        void operator=(S const&)  = delete;

        // Note: Scott Meyers mentions in his Effective Modern
        //       C++ book, that deleted functions should generally
        //       be public as it results in better error messages
        //       due to the compilers behavior to check accessibility
        //       before deleted status
};

То же самое: This implementation is known as Meyers' Singleton. 
В C++11 thread safe, прежде чем C++11 не thread safe.

class OnlyOne
{
public:
        static const OnlyOne& Instance()
        {
                static OnlyOne theSingleInstance;
                return theSingleInstance;
        }
private:        
        OnlyOne(){}
        OnlyOne(const OnlyOne& root);
        OnlyOne& operator=(const OnlyOne&);
};


//============================================================================
характеристики сортировок
//============================================================================

Вычислительная сложность - худшая, средняя и лучшая 
Устойчивость (англ. stability) — устойчивая сортировка не меняет взаимного расположения элементов с одинаковыми ключами (сортировка слиянием, Сортировка вставками (Insertion sort)).
Естественность поведения — эффективность метода при обработке уже упорядоченных или частично упорядоченных данных. 
                           Алгоритм ведёт себя естественно, если учитывает эту характеристику входной последовательности и работает лучше.
Использование операции сравнения - если только сравнение, то мин. трудоемкость n*log(n), если про данные известно больше, то можно быстрее.
Внутренняя сортировка - все данные в оперативной памяти, Внешняя сортировка - данные на устройстве с последовательным доступом.  
Требуется доп. память / не требуется доп. память.
потребность в знаниях о структуре данных, выходящих за рамки операции сравнения


//============================================================================
ООП
//============================================================================
Инкапсуляция
   bundling of data with the methods operating on that data
   restricting direct access to some of the object's components
Наследование
   механизм языка, позволяющий описать новый класс на основе уже существующего класса или интерфейса.
Полиморфизм
   is the provision of a single interface to entities of different types.
   способность программы обрабатывать данные разных типов

   
//============================================================================   
remove-erase   
//============================================================================
   
После создания в vector есть место только на 1 элемент, при вставке второго он уже будет расширяться.
При расширении vector вызываются кострукторы копий и деструкторы элементов.

noexcept:
implicitly-declared default constructors, copy constructors, move constructors, destructors, copy-assignment operators, move-assignment operators 
are all noexcept(true) by default, unless they are required to call a function that is noexcept(false), in which case these functions are noexcept(false). 

Чтобы при расширении vector вызывался move конструктор нужно написать:
Data(Data &&d) = default;    
или добавить noexcept
Data(Data &&d) noexcept :x(d.x) {} 

vector вызывает деструкторы с начала - к концу.   
   

v.erase(remove(v.begin(), v.end(), 10), v.end());

v.erase(remove_if(v.begin(), v.end(),[](int x)
    {
        return x % 2 == 0;            
    }),
    v.end());

int mod = 3;
    
auto afterRemove = remove_if(v.begin(), v.end(), [mod](Data &d)
    {
        return d.x % mod == 0;
    });

v.erase(afterRemove, v.end());

remove_erase.cpp

//============================================================================
References
//============================================================================

Things that are declared as rvalue reference can be lvalues or rvalues. 
The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue. 

void foo(X&& x)
{
    //Внутри метода x - lvalue, т.е. будет вызван конструктор копий.
    X anotherX = x;
    //x еще может использоваться здесь
}

http://thbecker.net/articles/rvalue_references/section_08.html
reference collapsing rules:
    A& & becomes A&
    A& && becomes A&
    A&& & becomes A&
    A&& && becomes A&&


*************************************************************************************************************************************************************                          
                          
                          
//============================================================================
priority_queue
//============================================================================
make_heap
push_heap
pop_heap

push O(log n)	
top O(1)	
pop O(log n)

Binary heap
https://en.wikipedia.org/wiki/Binary_heap

A binary heap is a heap data structure created using a binary tree. It can be seen as a binary tree with two additional constraints:[1]
Shape property
    A binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.
Heap property
    All nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison predicate defined for the heap. 

    Значение в любой вершине не меньше, чем значения её потомков.
    Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.
    Последний слой заполняется слева направо.
       

//============================================================================
Преобразования типов
//============================================================================

dynamic_cast
Оператор dynamic_cast может быть применён к указателям или ссылкам.
Обязательно в классе источнике должна быть virtual функция!!!
НЕ обязательно источник и target должны быть в одной иерархии наследования.
В случае если осуществляется преобразование указателя к типу данных, который не является фактическим типом объекта, 
в результате преобразования будет получен нулевой указатель. 
При работе со ссылками при невозможности преобразования типа будет сгенерировано исключение std::bad_cast.
Механизм динамической идентификации типа данных доступен только для полиморфных 
классов (т.е. классов, содержащих хотя бы одну виртуальную функцию-член)


c style cast
http://en.cppreference.com/w/cpp/language/explicit_cast
http://stackoverflow.com/questions/13960939/reinterpret-cast-vs-c-style-cast

A C-style cast is equivalent to the first of the following that succeeds:
    a const_cast
    a static_cast
    a static_cast followed by const_cast
    a reinterpret_cast
    a reinterpret_cast followed by const_cast

When the C-style cast expression is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:
a) const_cast<new_type>(expression);
b) static_cast<new_type>(expression), with extensions: pointer or reference to a derived class is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is inaccessible (that is, this cast ignores the private inheritance specifier). Same applies to casting pointer to member to pointer to member of unambigous non-virtual base;
c) static_cast (with extensions) followed by const_cast;
d) reinterpret_cast<new_type>(expression);
e) reinterpret_cast followed by const_cast.
The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). 
If the cast can be interpreted in more than one way as static_cast followed by a const_cast, it cannot be compiled.
    
    
    
static_cast
http://en.cppreference.com/w/cpp/language/static_cast
The type parameter must be a data type for which there is a known method for converting object to, whether this be a builtin or through a casting function.
All types of conversions that are well-defined and allowed by the compiler are done using static_cast.
The static_cast operator can be used for operations such as

    Converting a pointer of a base class to a pointer of a derived class,
    Convert numeric data types such as enums to ints or ints to floats.

However, static_cast conversions are not necessarily safe as no run-time type check is done which can cause casting between incompatible data types, 
for example pointers. 
However, this is checked at compile time to prevent casting obvious incompatibles. 
Also, static_cast between pointer of a virtual base to pointer of derived is not allowed, because of the object layout model.
Если это встроенные типы, то будут использованы встроенные в C++ правила их приведения. 
Если это типы, определенные программистом, то будут использованы правила приведения, определенные программистом.
возможно такое приведение: static_cast<Derived*>(pBase), даже если pBase не указывает на Derived, но после этого поведение программы не определено.
Обычно static_cast используется, когда требуется преобразовать числовые типы данных, например перечисления в целые числа или целые числа в числа с плавающей запятой, 
и при полной уверенности в том, какие типы данных используются в преобразовании.

 If new_type is a pointer or reference to some class D and the type of expression is a pointer or reference to its non-virtual base B, 
 static_cast performs a downcast. Such static_cast makes no runtime checks to ensure that the object's runtime type is actually D

static_cast можно от родителя делать сына. Одного сына преобразовать в другого нельзя. 
static_cast нельзя pointer превращать в int и наоборот.

int intVal = reinterpret_cast<int>(pointer); error: cast from ‘Dog*’ to ‘int’ loses precision
int intVal = (int)pd; error: cast from ‘Dog*’ to ‘int’ loses precision

reinterpret_cast НЕ может убрать const.

        //iVal = reinterpret_cast<int>(longlongVal); //error
        iVal = static_cast<int>(longlongVal);        //Ok
        //longlongVal = reinterpret_cast<long long int>(iVal); //error
        //floatVal = reinterpret_cast<float>(iVal); //error
        //uiVal = reinterpret_cast<unsigned int>(iVal); //error


Резюме:

   * static_cast - допустимые приведения времени компиляции. Можно неправильно преобразовать parent в неправильного child.
   * dynamic_cast - source только указатель или ссылка на тип с virtual функциями. 
НЕ обязательно источник и target должны быть в одной иерархии наследования.
Неправильное преобразование указатель - nullptr, ссылка - exception std::bad_cast.
   * reinterpret_cast - любые преобразования. НЕ может убирать const. Не может loses precision. Не преобразует значения разных базовых типов.
   * const_cast - убирает const.

   
//============================================================================
RTTI
//============================================================================

typeid()
The header <typeinfo> must be included before using typeid.
Можно использовать на любых типах - полиморфных, обычных, базовых.
Если тип не полиморфный - то возвращается static информация во время компиляции.
Полиморфный typeid можно использовать на указателях и ссылках.

Возвращает std::type_info
operator==
operator!=
hash_code
name
before       (checks whether the referred type precedes referred type of another type_index object in the implementation defined order, i.e. orders the referred types)

std::type_index (C++11)
The type_index class is a wrapper class around a std::type_info object, that can be used as index in associative and unordered associative containers.
operator==
operator!=
operator<
operator<=
operator>
operator>=
hash_code
name


//============================================================================
size_t
//============================================================================
It is a type able to represent the size of any object in bytes
Ubuntu64 g++ sizeof(size_t)==8
is result of sizeof operator
is unsigned


//============================================================================
default, delete functions
//============================================================================

You can delete special member functions as well as normal member functions and non-member functions to prevent them from being defined or called.

deleted functions still participate in overload resolution. 
The function call resolves to the more-specific—but deleted—function and causes a compiler error.

Function that can be called only with double argument:
template < typename T >
void call_with_true_double_only(T) =delete; //prevent call through type promotion of any T to double from succeeding.
void call_with_true_double_only(double param) { return; } // also define for const double, double&, etc. as needed.

                          
//============================================================================
move semantics
//============================================================================
http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html

return value optimization
return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function's return value.
https://en.wikipedia.org/wiki/Return_value_optimization
https://en.wikipedia.org/wiki/Copy_elision
https://en.wikipedia.org/wiki/As-if_rule

The standard for the C++ programming language allows compilers for this language to apply any optimizating transformation to a program during compilation, 
provided that such optimizations make no change in the "observable behavior" of the program, as specified in the standard; 
this mostly means that any actions the program performs on its environment occur in the specified order. 
This rule is commonly referred to as the as-if rule.
The rule has three main exceptions. The first is that programs exhibiting undefined behavior are exempt; 
since the observable behavior is not well-defined anyway, any transformation is valid. 
The other two exceptions concern the copying of objects, and are called copy elision and the return value optimization.

move semantics позволяет хранить в stl контейнерах некопируемые объекты.
https://habrahabr.ru/post/174019/


//============================================================================
function call resolution
//============================================================================

Argument-dependent lookup
http://en.cppreference.com/w/cpp/language/adl
Argument-dependent lookup, also known as ADL, or Koenig lookup, 
is the set of rules for looking up the unqualified function names in function-call expressions, 
including implicit function calls to overloaded operators. 
These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces 
considered by the usual unqualified name lookup. 
Argument-dependent lookup makes it possible to use operators defined in a different namespace.

Template argument deduction
http://en.cppreference.com/w/cpp/language/template_argument_deduction
In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. 
When possible, the compiler will deduce the missing template arguments from the function arguments.


//============================================================================
unicode
//============================================================================

character type sizes - look in small_progs/type_limits.cpp


//============================================================================
traits
//============================================================================

https://erdani.com/publications/traits.html
In short, traits are important because they allow you to make compile-time decisions based on types, 
much as you would make runtime decisions based on values. 
Better still, by adding the proverbial "extra level of indirection" that solves many software engineering problems, 
traits let you take the type decisions out of the immediate context where they are made. 
This makes the resulting code cleaner, more readable, and easier to maintain. 
If you apply traits correctly, you get these advantages without paying the cost in performance, safety, or coupling that other solutions might exact. 

sample implementation:
small_progs/type_limits.cpp

https://erdani.com/publications/traits.html

traits are important because they allow you to make compile-time decisions based on types, 
much as you would make runtime decisions based on values.

Traits rely on explicit template specialization to pull out type-related variations from code, and to wrap them under a uniform interface.

A traits template is a template class, possibly explicitly specialized, 
that provides a uniform symbolic interface over a coherent set of design choices that vary from one type to another.


//============================================================================
multimap multiset
//============================================================================

learn_algorithms/codeforces_archive/659b_multimap.cpp
learn_algorithms/codeforces_archive/659b_multiset.cpp
small_progs/learn_multimap_multiset.cpp

multimap<string,string> mm;

//insert
mm.insert(make_pair("key1","val11"));
mm.emplace("key1","val12");

//iterate
for(auto &p : mm)
{
	cout <<p.first<<" "<<p.second<<endl;	    	
}
cout <<mm.begin()->first<<endl;   


//get elements by key (p is pair - first, second)
auto p = mm.equal_range(key); 
    
for(auto it=p.first;it!=p.second;++it)
{
	cout <<it->second<<endl;	
}

//get number of found items:
cout <<"number of items: "<<distance(p.first,p.second)<<endl;

//erase
int removedCount = mm.erase(key); //Return value Number of elements removed.
auto p2 = mm.equal_range(key);
mm.erase(p2.first,p2.second); //Return value  Iterator following the last removed element.
auto p2 = mm.equal_range(key);
mm.erase(p2.first); //Return value  Iterator following the last removed element.

//number of elements with specific key:
mm.count(key);

//number of elements
mm.size();


//============================================================================
priority_queue
//============================================================================

default container - class Container = vector<T>

const_reference top() const;
void pop();
void push (const value_type& val);
template <class... Args> void emplace (Args&&... args);

    //=================== priority queue ==========================    
    priority_queue<string> q;
    q.push("hello");
    q.emplace("world");
    q.push("program");
    cout <<q.top()<<" "<<q.top()<<q.size()<<endl;
    q.pop();
    cout <<q.top()<<" "<<q.top()<<q.size()<<endl;    
    //=================== priority queue ==========================


//============================================================================    
const pointer and pointer to const    
//============================================================================    

Если слово const перед звездочкой (не важно перед или после int) - то
это изменяемый указатель на константные данные.
Сам указатель константный только если const стоит после звездочки.

int const * - pointer to const int
int * const - const pointer to int
int const * const - const pointer to const int

Now the first const can be on either side of the type so:
    const int * == int const *
    const int * const == int const * const


//============================================================================
posix processes
//============================================================================

show all processes on system:
ps -e

send program SIGTERM signal
kill
kill (child_pid, SIGTERM);

Получить номера сигналов:
/bin/kill --table
 1 HUP      2 INT      3 QUIT     4 ILL      5 TRAP     6 ABRT     7 BUS
 8 FPE      9 KILL    10 USR1    11 SEGV    12 USR2    13 PIPE    14 ALRM
15 TERM    16 STKFLT  17 CHLD    18 CONT    19 STOP    20 TSTP    21 TTIN
22 TTOU    23 URG     24 XCPU    25 XFSZ    26 VTALRM  27 PROF    28 WINCH
29 POLL    30 PWR     31 SYS     

//------------------------------------------------

system creates a subprocess running the standard Bourne shell (/bin/sh)
and hands the command to that shell for execution
return_value = system ("ls -l /");

//------------------------------------------------

fork:
learn_system.cpp

pid_t result=fork();
if(result==0)
{
	cout <<"child"<<endl;
}
else if(result>0)
{
	cout <<"parent"<<endl;	
}
else
{
	cout <<"error!"<<endl;    
}

//------------------------------------------------

exec:
int result = execlp("echo","echo","hello!","world!",NULL);
cout <<"exec failed! "<<result<<endl;

//------------------------------------------------

nice - set process priority
program and function
больше nice - меньше priority
Niceness values range from -20 (most favorable to the process) to 19 (least favorable to the process).
nice()  adds  inc to the nice value for the calling process.  (A higher nice value means a low priority.)  Only the
superuser may specify a negative increment, or priority increase.

int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int prio);

//------------------------------------------------

signals:
you should avoid performing any I/O operations or calling most library
and system functions from signal handlers. In
most cases, this consists simply of recording the fact that a signal occurred.The main
program then checks periodically whether a signal has occurred and reacts accordingly.

The SIGTERM
signal asks a process to terminate; the process may
ignore the request by masking or ignoring the signal.
The SIGKILL signal always kills the process
immediately because the process may not mask or ignore  SIGKILL

signal(SIGINT,sig_int_handler);
void sig_int_handler(int i)
{ 
    printf("sig int handler\r\n");
    exit(-1);
}
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

sig_atomic_t sigusr1_count = 0;
void handler (int signal_number)
{
	++sigusr1_count;
}
struct sigaction sa;
memset (&sa, 0, sizeof (sa));
sa.sa_handler = &handler;
sigaction (SIGUSR1, &sa, NULL);
printf (“SIGUSR1 was raised %d times\n”, sigusr1_count);

ожидать завершения ребенка:
int child_status;
wait (&child_status);
if (WIFEXITED (child_status))
	printf (“the child process exited normally, with exit code %d\n”,WEXITSTATUS (child_status));
else
	printf (“the child process exited abnormally\n”);

Также waitpid, waitid.

A zombie process is a process that has terminated but has not been cleaned up yet (wait не была вызвана).

When a program exits, its children are inherited by a special process, the init program, which
always runs with process ID of 1 (it ’s the first process started when Linux boots).The init
process automatically cleans up any zombie child processes that it inherits.

wait3 or wait4 have parameter not to wait, immediately return if no child events exist.
When a child process terminates, Linux sends the parent process the SIGCHLD signal.
an easy way to clean up child processes is by handling SIGCHLD


//============================================================================
posix threads
//============================================================================
//нужно добавлять библиотеку:
g++ -lpthread

pthread_create
pthread_join(thread_handle,(void**)&thread_result);

The pthread_self function returns the thread ID of the thread in which it is called

A joinable thread, like a process, is not automatically cleaned up by GNU/Linux when it terminates. 
Instead, the thread’s exit
state hangs around in the system (kind of like a zombie process) until another thread
calls pthread_join to obtain its return value. Only then are its resources released.

A detached thread, in contrast, is cleaned up automatically when it terminates. 

Create detached thread:
pthread_attr_t attr;
pthread_attr_init (&attr);
pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);	
pthread_create (&thread, &attr, &thread_function, NULL);
pthread_attr_destroy (&attr);

Set thread to detached mode after creation: call pthread_detach

A thread may be in one of three states with regard to thread cancellation.

The thread may be asynchronously cancelable
The thread may be canceled at any point in its execution.

The thread may be synchronously cancelable
The thread may be canceled, but not at just any point in its execution. Instead, cancellation requests are queued, and
the thread is canceled only when it reaches specific points in its execution.

A thread may be uncancelable
Attempts to cancel the thread are quietly ignored.

When initially created, a thread is synchronously cancelable.

Функция для установки cancel state:
pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, NULL);


Thread specific data:
pthread_key_create
pthread_getspecific
pthread_setspecific

Thread cleanup handlers - функции, которые вызываются при завершении потока.
pthread_cleanup_push
pthread_cleanup_pop


Мютексы:
pthread_mutex_t mutex;
pthread_mutex_init (&mutex, NULL);
pthread_mutex_lock (&job_queue_mutex);
pthread_mutex_unlock (&job_queue_mutex);

A simple type of deadlock may occur when the same thread attempts to lock a mutex twice in a row.
Есть при типа поведения:
* Locking a fast mutex (the default kind) will cause a deadlock to occur. 
* Locking a recursive mutex does not cause a deadlock.
* GNU/Linux will detect and flag a double lock on an error-checking mutex that
would otherwise cause a deadlock.The second consecutive call to pthread_mutex_lock returns the failure code EDEADLK.

By default, a GNU/Linux mutex is of the fast kind. Другие получаются так:
pthread_mutexattr_t attr;
pthread_mutex_t mutex;
pthread_mutexattr_init (&attr);
pthread_mutexattr_setkind_np (&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
pthread_mutex_init (&mutex, &attr);
pthread_mutexattr_destroy (&attr);

Nonblocking Mutex Tests:
pthread_mutex_trylock


Semaphores for Threads
sem_init
sem_post
sem_wait

Conditional variable
1. The loop in thread_function locks the mutex and reads the flag value.
2.  If the flag is set, it unlocks the mutex and executes the work function.
3.  If the flag is not set, it atomically unlocks the mutex and waits on the condition variable.
The critical feature here is in step 3, in which GNU/Linux allows you to unlock the
mutex and wait on the condition variable atomically, without the possibility of
another thread intervening.

pthread_cond_init initializes a condition variable.
pthread_cond_signal signals a condition variable. A single thread that is blocked on the condition variable will be unblocked. 
pthread_cond_broadcast unblocks all threads that are blocked on the condition variable, instead of just one.
pthread_cond_wait blocks the calling thread until the condition variable is signaled.

Whenever your program performs an action that may change the sense of the condition you’re protecting with the condition variable, it should perform these steps: 
1.  Lock the mutex accompanying the condition variable.
2.  Take the action that may change the sense of the condition (in our example, set the flag).
3.  Signal or broadcast the condition variable, depending on the desired behavior.
4.  Unlock the mutex accompanying the condition variable.

Wait for conditional variable:
pthread_mutex_lock (&thread_flag_mutex);
while (!thread_flag)
{
    pthread_cond_wait (&thread_flag_cv, &thread_flag_mutex);
}
pthread_mutex_unlock (&thread_flag_mutex);

The implementation of POSIX threads on GNU/Linux differs from the thread imple-
mentation on many other UNIX-like systems in an important way: on GNU/Linux,
threads are implemented as processes.Whenever you call pthread_create to create a
new thread, Linux creates a new process that runs that thread. However, this process is
not the same as a process you would create with fork; in particular, it shares the same
address space and resources as the original process rather than receiving copies.

Within a multithreaded program, it is possible for one thread to send a signal
specifically to another thread. Use the pthread_kill function to do this. Its first parameter is a thread ID, and its second parameter is a signal number.


//============================================================================
posix ipc
//============================================================================

//----------------------------------------

* Shared memory 
permits processes to communicate by simply reading and 
writing to a specified memory location.

* Process Semaphores System V

* Process Semaphores Posix

* Mapped memory 
is similar to shared memory, except that it is associated with a
file in the filesystem. 

* Pipes
permit sequential communication from one process to a related process.

* FIFO (Named Pipes)
are similar to pipes, except that unrelated processes can communicate
because the pipe is given a name in the filesystem.

* Sockets (PF_LOCAL and PF_UNIX)
support communication between unrelated processes even on different computers.

//----------------------------------------


Shared memory

Shared memory is the fastest form of interprocess communication because all
processes share the same piece of memory. Access to this shared memory is as fast as
accessing a process’s nonshared memory, and it does not require a system call or entry to the kernel. 

shmget - allocate shared memory.
int segment_id = shmget (shm_key, getpagesize (),IPC_CREAT |S_IRUSR |S_IWUSER);

shmat - attach shared memory.
shmdt - detach shared memory.
shmctl - get and set shared memory params.

ipcs command provides information on interprocess communication facilities


//----------------------------------------

Process Semaphores System V

process semaphores or sometimes System V (System Five) semaphores. 

//allocate semaphore
semget (key, 1, sem_flags);

//deallocate semaphore
semctl (semid, 1, IPC_RMID, ignored_argument);

To initialize a semaphore, use semctl with zero as the second argument and SETALL as the third argument.

semop - wait and post operations.

//----------------------------------------

Process Semaphores Posix

sem_open
sem_wait
sem_post
sem_getvalue
sem_close
sem_unlink

//----------------------------------------

Memory Mapped files
mmap - map file.

int fd = open (argv[1], O_RDWR |O_CREAT, S_IRUSR |S_IWUSR);
file_memory = mmap (0, FILE_LENGTH, PROT_WRITE, MAP_SHARED, fd, 0);
close (fd);

//----------------------------------------

Pipes

int pipe_fds[2];
int read_fd;
int write_fd;
pipe (pipe_fds);
read_fd = pipe_fds[0];
write_fd = pipe_fds[1];

//Connect the read end of the pipe to standard input 
dup2 (fds[0], STDIN_FILENO);

Размер буфера pipe по-умолчанию в ubuntu14.04 64bit - 65536 байт.

popen / pclose - run child process and create pipe to it
FILE* stream = popen (“sort”, “w”); //sort - name of unix program.
fprintf (stream, “This is a test.\n”);
fprintf (stream, “Hello, world.\n”);
pclose (stream);

The call to popencreates a child process executing the sortcommand, replacing callsto pipe,fork,dup2, and execlp.
The second argument, “w”, indicates that this processwants to write to the child process

//----------------------------------------

FIFO (named pipes)

A first-in, first-out (FIFO) file is a pipe that has a name in the filesystem.

To make fifo in bash: mkfifo /tmp/somefifoname 

in program - mkfifo function.

Access a FIFO just like an ordinary file

A FIFO can have multiple readers or multiple writers. Bytes from each writer are
written atomically up to a maximum size of PIPE_BUF (4KB on Linux). Chunks from
simultaneous writers can be interleaved. Similar rules apply to simultaneous reads.

//----------------------------------------

Sockets
Sockets connecting processes on the same computer can use the local namespace represented by the synonyms 
PF_LOCAL and PF_UNIX.These are called local sockets or UNIX-domain sockets.

PF_LOCAL, PF_UNIX создает файл в файловой системе. После окончания работы нужно вызвать unlink(file_name)

socket_fd = socket (PF_LOCAL, SOCK_STREAM, 0);

socketpair - создать пару сокетов для связанных процессов (только PF_LOCAL).


//============================================================================
stl and thread safety
//============================================================================

http://en.cppreference.com/w/cpp/container#Thread_safety

* All container functions can be called concurrently by different threads on different containers. 
* All const member functions can be called concurrently by different threads on the same container. 
In addition, the member functions begin(), end(), rbegin(), rend(), front(), back(), data(), find(), lower_bound(), upper_bound(), equal_range(), at(), and, 
except in associative containers, operator[], behave as const for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). 
More generally, the C++ standard library functions do not modify objects unless those objects are accessible, 
directly or indirectly, via the function's non-const arguments
* Different elements in the same container can be modified concurrently by different threads, except for the elements of std::vector<bool> 
* Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, 
and may be executed concurrently with operations on other iterators on the same container, 
with the const member functions, or reads from the elements. 
Container operations that invalidate any iterators modify the container and cannot be executed concurrently 
with any operations on existing iterators even if those iterators are not invalidated. 
* Elements of the same container can be modified concurrently with those member functions that are not specified to access these elements.
* In any case, container operations (as well as algorithms, or any other C++ standard library functions) 
may be parallelized internally as long as this does not change the user-visible results. 


//============================================================================
c++11 futures
//============================================================================
small_progs/futures.cpp

void work1(int x, int y, int z, promise<int> result)
{
    result.set_value(x+y+z);
}

void test1()
{
    promise<int> myPromise1;
    future<int> myFuture1 = myPromise1.get_future();
    thread myThread1(work1,1,2,3,move(myPromise1));
    
    myFuture1.wait();
    int result = myFuture1.get();
    
    debug2("%d",result);
    
    myThread1.join();    
}

The promise is the "push" end of the promise-future communication channel: 
the operation that stores a value in the shared state, 
the successful return from any function that is waiting on the shared state (such as std::future::get).


promise-future with exception:
void work2(int x, int y, int z, promise<int> result)
{
    result.set_exception(make_exception_ptr(invalid_argument("works2!")));
}

void test2()
{    
    promise<int> myPromise1;
    future<int> myFuture1 = myPromise1.get_future();
    thread myThread1(work2,1,2,3,move(myPromise1));
    
    myFuture1.wait();

    try{
        int result = myFuture1.get();
        debug2("%d",result);
    }catch(invalid_argument ex){
        cout <<"catch in main thread: "<<ex.what()<<endl;
    }    

    myThread1.join();
}

promise - объект, который передается в поток для возврата значения.
future - объект, который используется в главном потоке для получения значения.

//-----------------------------------------------------------------

http://stackoverflow.com/questions/18143661/what-is-the-difference-between-packaged-task-and-async

async and ~future Herb Sutter:
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf

std::futures from std::async aren't special!  Scott Meyers
http://scottmeyers.blogspot.ru/2013/03/stdfutures-from-stdasync-arent-special.html


int work3(int x, int y, int z)
{
    return x+y+z;
}

void test_packaged_task1()
{
    packaged_task<int()> pack_task(bind(work3,1,2,3));
    future<int> future1 = pack_task.get_future();
    pack_task();
    int result = future1.get();
    debug2("packaged task: %d",result);   
}

get_future can be called only once for each packaged_task. 

//-----------------------------------------------------------------

shared_future - можно копировать, все копии связаны с одним результатом. 
Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a shared_future object. 

//-----------------------------------------------------------------

std::async - template function async runs the function f asynchronously (potentially in a separate thread which may be part of a thread pool) 
and returns a std::future that will eventually hold the result of that function call. 

Simply spoken a std::packaged_task is a std::function linked to a std::future and std::async wraps and calls a std::packaged_task


//============================================================================
ICMP socket
//============================================================================
/mnt/programs/programs/programs2/mylib/icmp_echo.c

ping:
socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)
sendto(sock,(void*)&opckt,SOF_OPCKT,0,(struct sockaddr*)&si,sizeof(struct sockaddr_in)
read(fd,buf,buf_size)
close(sock);


//============================================================================
poll / select
//============================================================================
http_server.cpp

select:

fd_set select_read_fds;
FD_ZERO(&select_read_fds);
FD_SET(sockfd, &select_read_fds);

int selectResult = select( max_select_fd + 1 , &select_read_fds , NULL , NULL , NULL);

if(selectResult>0)
{    
    if (FD_ISSET(sockfd, &select_read_fds)) 
    {
        new_socket = accept(sockfd, (struct sockaddr *)&address, (socklen_t*)&addrlen)        
    }
    
    if(FD_ISSET(client_socket[i],&select_read_fds))
    {
        int numBytes = recv(client_socket_fd,buf,bufSize-1,0);
    }    
}


poll:

    const int max_poll_fds=1000;
    struct pollfd poll_fds[max_poll_fds];
    int poll_fds_size=1;
    
    poll_fds[0].fd=sockfd;
    poll_fds[0].events=POLLIN;

    int result = poll(poll_fds,poll_fds_size,5000);
    
    if(result>0)
    {
            for(int i=0;i<poll_fds_size;i++)
            {
                if(poll_fds[i].revents & POLLIN)
                {
                        int client_socket_fd=poll_fds[i].fd;                        
                        int numBytes = recv(client_socket_fd,buf,bufSize-1,0);
                        
                        if(numBytes==0)
                        {
                            close(client_socket_fd);
                            poll_fds[i].fd=-1;
                        }                        
                }
            }
    }

//============================================================================
design pattern
//============================================================================
повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

https://en.wikipedia.org/wiki/Design_Patterns

Patterns by Type
   Creational (Порождающие)
      Abstract factory pattern
      Prototype pattern
      Singleton pattern
   Structural (Структурные)
      Adapter
      Facade
      Proxy
   Behavioral (Поведенческие)
      Template method
      Iterator
      command
      

Creational
Abstract factory - groups object factories that have a common theme
interface IButton
{
    void Paint();
}
interface IGUIFactory
{
    IButton CreateButton();
}
class WinFactory : IGUIFactory
{
    public IButton CreateButton()
    {
        return new WinButton();
    }
}

class OSXFactory : IGUIFactory
{
    public IButton CreateButton()
    {
        return new OSXButton();
    }
}
IGUIFactory factory;
switch (appearance)
{
    case Appearance.Win:
        factory = new WinFactory();
        break;
    case Appearance.OSX:
        factory = new OSXFactory();
        break;
    default:
        throw new System.NotImplementedException();
}
var button = factory.CreateButton();

//---------------------------------------------------------

Singleton - restricts object creation for a class to only one instance.

//---------------------------------------------------------

Factory method -  creating objects by calling a factory method—either specified in an interface and implemented by child classes, 
or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.
public class MagicMazeGame extends MazeGame {
    @Override
    protected Room makeRoom() {
        return new MagicRoom(); 
    }
}
public class OrdinaryMazeGame extends MazeGame {
    @Override
    protected Room makeRoom() {
        return new OrdinaryRoom(); 
    }
}

//---------------------------------------------------------

Prototype pattern
It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.
public abstract class Prototype
{
    // normal implementation
    public abstract Prototype Clone();
}
public class ConcretePrototype1 : Prototype
{
    public override Prototype Clone()
    {
        return (Prototype)this.MemberwiseClone(); // Clones the concrete class.
    }
}
public class ConcretePrototype2 : Prototype
{
    public override Prototype Clone()
    {
        return (Prototype)this.MemberwiseClone(); // Clones the concrete class.
    }
}

//---------------------------------------------------------

*************** Structural *********************

//---------------------------------------------------------------
Adapter
adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface.
The Adapter design pattern allows otherwise incompatible classes to work together by converting the interface of one class into an interface expected by the clients.

//---------------------------------------------------------------
Facade
A facade is an object that provides a simplified interface to a larger body of code, such as a class library.

    make a software library easier to use, understand and test, since the facade has convenient methods for common tasks;
    make the library more readable, for the same reason;
    reduce dependencies of outside code on the inner workings of a library, since most code uses the facade, thus allowing more flexibility in developing the system;
    wrap a poorly designed collection of APIs with a single well-designed API.

//---------------------------------------------------------------
Decorator



*************** Behavioral *********************

command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event 
at a later time. This information includes the method name, the object that owns the method and values for the method parameters.
Пример: SqlCommand

Iterator

Template method


//============================================================================
object slicing
//============================================================================

"Slicing" is where you assign an object of a derived class to an instance of a base class, 
thereby losing part of the information - some of it is "sliced" away.
slicing occurs during method calls

C++ lets you pass an instance of B to A's assignment operator (and also to the copy constructor). 
This works because an instance of B can be converted to a const A&, 
which is what assignment operators and copy-constructors expect their arguments to be.

B b1;
B b2;
A& a_ref = b2;
a_ref = b1;
//b_2 now contains a mixture of b1 and b2!

What happened? Well, C++ by default doesn't treat assignment operators as virtual. 
Thus, the line a_ref = b1 will call the assignment operator of A, not that of B.
assignment operator can be made virtual.

slicing during function call:
void function(A myA)
{
}

B derived;
function(derived);

//============================================================================
nothrow new, placement new
//============================================================================

Стандартный оператор operator new[]
выделяет на 4 байта больше, чем требуется для хранения объектов,
перед объектами размещается 4 байта в них записано количество ОБЪЕКТОВ в массиве.

operator new первым параметром должен иметь size,
потом могут быть любые параметры:
    void* operator new[](size_t size, double dArg, string sArg)

User *usrs = new (1.23,string("test")) User[5];

nothrow new :

int *p = new (std::nothrow) int[100000000];


//--- placement new ---

new (pointer) ClassName(constructor_params);

void test3()
{
    char *p = new char[1000000];
    
    Client *pCli1 = new (p) Client();
    pCli1->~Client();
    
    delete[] p;    
    
    //---------------------
    
    p=new char[sizeof(Client)*5];
    Client *pCli2 = reinterpret_cast<Client*>(p);
    
    for(int i=0;i<5;++i)
    {
        new (pCli2+i) Client();    
    }
    
    for(int i=4;i>=0;--i)
    {
        pCli2[i].~Client();    
    }
    
    delete[] p;
}

placement delete нет.
Нужно руками вызвать деструкторы объектов и освободить память.

//============================================================================
virtual destructor
//============================================================================

Virtual destructors are useful when you can delete an instance of a derived class through a pointer to base class
if Base's destructor is not virtual and b is a Base* pointing to a Derived object, 
delete b has undefined behaviour

always make base classes' destructors virtual when they're meant to be manipulated polymorphically.
If you want to prevent the deletion of an instance through a base class pointer, 
you can make the base class destuctor protected and nonvirtual; 
by doing so, the compiler won't let you call delete on a base class pointer.


//============================================================================
размер куска в deque (g++)
//============================================================================

//stl_deque.h

#ifndef _GLIBCXX_DEQUE_BUF_SIZE
#define _GLIBCXX_DEQUE_BUF_SIZE 512
#endif

  inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }

Т.е. размер куска в объектах равен количеству объектов, умещающихся в 512 байт,
если объект >= 512 байт - то в каждом куске один объект.

*  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
*
*  - Tp**        _M_map
*  - size_t      _M_map_size
*  - iterator    _M_start, _M_finish

*  If Tp
*  is very large, there will be one Tp element per node (i.e., an
*  @a array of one).  For non-huge Tp's, node size is inversely
*  related to Tp size: the larger the Tp, the fewer Tp's will fit
*  in a node.  The goal here is to keep the total size of a node
*  relatively small and constant over different Tp's, to improve
*  allocator efficiency.

*  If
*  the initial number of elements in the deque is small, the
*  /middle/ %map pointers will be valid, and the ones at the edges
*  will be unused.  This same situation will arise as the %map
*  grows: available %map pointers, if any, will be on the ends.
*  map_size is at least 8.
*  enum { _S_initial_map_size = 8 };

//============================================================================
Почему константы объявляют как enum?
//============================================================================

An enumeration implies a set of related constants, so the added information about the relationship must be useful in their model of the problem at hand.
Enums are distinct types, so you can do type-oriented things like overloading with them.

In older versions of C++, static const was not supported inside classes. 
This meant that const was useless for constant expressions inside classes. 
However, people still wanted to do this so a typical solution 
(usually referred to as the “enum hack”) was to use an untagged enum with no instances. 
An enumeration must have all its values established at compile time, 
it’s local to the class, and its values are available for constant expressions.

It's because enum never gets any storage while const variable is still a variable 
and will get (static) storage if the compiler can't proove it won't need one, 
which it often can't.


//============================================================================
non type template parameters
//============================================================================

A non-type template-parameter shall have one of the following (optionally cv-qualified) types:
    integral or enumeration type,
    pointer to object or pointer to function,
    lvalue reference to object or lvalue reference to function,
    pointer to member,
    std::nullptr_t.

for the case of pointers to objects (or instance fields), 
the objects must have static storage duration and linkage (external pre C++11, 
internal or external in C++11), 
so that pointers to them can be created at compile time. 
(т.е. нельзя использовать переменные на стеке или в куче, только глобальные переменные).

http://en.cppreference.com/w/cpp/language/template_parameters

In particular, this implies that string literals, addresses of array elements, 
and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects. 

float, double нельзя использовать, т.к. вычисления с плавающей точкой не точные
в примере не известно - будет использоваться одна и та же функция или будут созданы две разные.
func<1/3.f> (); 
func<2/6.f> ();
template class foo<10./3.>
template class foo<1./3 * 10.>

Еще вариант:
In 2003 - yes, 2003 - Vandervoorde and Josuttis wrote this in their book "C++ Templates" (p. 40):
Not being able to use floating-point literals (and simple constant floating-point expressions) as template arguments 
has historical reasons. Because there are no serious technical challenges, 
this may be supported in future versions of C++.

C++ does not currently support the use of string literals (or real literals) as template parameters.


//============================================================================
typename
//============================================================================

typename можно использовать вместо class при описании шаблона. 
То есть вместо template<class T> можно написать template<typename T>, разницы никакой нет.

Stroustrup originally used class to specify types in templates to avoid introducing a new keyword. 
Some in the committee worried that this overloading of the keyword led to confusion. 
Later, the committee introduced a new keyword typename to resolve syntactic ambiguity, 
and decided to let it also be used to specify template types to reduce confusion, 
but for backward compatibility, class kept its overloaded meaning.

typename применяется, чтобы помочь компилятору определить, что выражение является именем типа:
template<class T> void f() { T::x * p; ... } 
T::x * p; - либо умножение, либо объявление переменной. 
Чтобы не было непонятности нужно писать:
typename T::x * p;


//============================================================================
точки следования (sequence points)
//============================================================================

A sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, 
and no side effects from subsequent evaluations have yet been performed.

Точки следования (sequence points) - это некие точки в программе, где состояние реальной программы полностью соответствует состоянию абстрактной машины, описанной в Стандарте.
Где находятся:
В конце каждого полного выражения(Глава Стандарта 1.9/16). Обычно они помечены точкой с запятой ;
В точке вызова функции (1.9/17). Но после вычисления всех аргументов. Это и для inline функций в том числе.
При возвращении из функции. (1.9/17) Есть точка следования сразу после возврата функции, перед тем как любой другой код из вызвавшей функции начал выполняться.
После первого выражения (здесь оно называется 'a') в следующих конструкциях:
a || b
a && b
a , b
a ? b : c
(Правило слево-направо не работает для переопределенных операторов. В этом случае переопределенный оператор ведет себя как обычная функция.)

Если программа пытается модифицировать одну переменную дважды не пересекая точку следования, то это ведет к undefined behavior.


With C++11, usage of the term sequence point has been replaced by sequencing. There are three possibilities:[1][2][3]

    An expression's evaluation can be sequenced before that of another expression, or equivalently the other expression's evaluation is sequenced after that of the first.
    The expressions' evaluation is indeterminately sequenced, meaning one is sequenced before the other, but which is unspecified.
    The expressions' evaluation is unsequenced.

The execution of unsequenced evaluations can overlap, with catastrophic undefined behavior if a write to an object is unsequenced with regard to another access to the same.

in the expression f()+g() it is possible that either f() or g() will be executed first.

(In C++, overloaded operators act like functions, and thus operators that have been overloaded introduce sequence points in the same way as function calls.)


    * Between evaluation of the left and right operands of the && (logical AND), || (logical OR) (as part of short-circuit evaluation), and comma operators. For example, in the expression *p++ != 0 && *q++ != 0, all side effects of the sub-expression *p++ != 0 are completed before any attempt to access q.
    * Between the evaluation of the first operand of the ternary "question-mark" operator and the second or third operand. For example, in the expression a = (*p++) ? (*p++) : 0 there is a sequence point after the first *p++, meaning it has already been incremented by the time the second instance is executed.
    * At the end of a full expression. This category includes expression statements (such as the assignment a=b;), return statements, the controlling expressions of if, switch, while, or do-while statements, and all three expressions in a for statement.
    * Before a function is entered in a function call. The order in which the arguments are evaluated is not specified, but this sequence point means that all of their side effects are complete before the function is entered. In the expression f(i++) + g(j++) + h(k++), f is called with a parameter of the original value of i, but i is incremented before entering the body of f. Similarly, j and k are updated before entering g and h respectively. However, it is not specified in which order f(), g(), h() are executed, nor in which order i, j, k are incremented. Variables j and k in the body of f may or may not have been already incremented. Note that a function call f(a,b,c) is not a use of the comma operator and the order of evaluation for a, b, and c is unspecified.
    * At a function return, after the return value is copied into the calling context. (This sequence point is only specified in the C++ standard; it is present only implicitly in C.[7])
    * At the end of an initializer; for example, after the evaluation of 5 in the declaration int a = 5;.
    * Between each declarator in each declarator sequence; for example, between the two evaluations of a++ in int x = a++, y = a++.[8] Note that this is not an example of the comma operator.
    * After the action associated with input/output conversion format specifier. For example, in the expression printf("foo %n %d", &a, 42), there is a sequence point after the %n is evaluated before printing 42.

https://en.wikipedia.org/wiki/Sequence_point

Assignment in c++:
Associativity - Right-to-left 


//============================================================================
static polymorphism
//============================================================================

Polymorphism - is the provision of a single interface to entities of different types.

https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
// The Curiously Recurring Template Pattern (CRTP)
template<class T>
class Base
{
    // methods within Base can use template to access members of Derived
};
class Derived : public Base<Derived>
{
    // ...
};


//============================================================================
Типы наследования
//============================================================================

If the inheritance is public, everything that is aware of Base and Child is also aware that Child inherits from Base.
If the inheritance is protected, only Child, and its children, are aware that they inherit from Base.
If the inheritance is private, no one other than Child is aware of the inheritance.

When you inherit a base class publicly, all members keep their original access specifications. 
Private members stay private, protected members stay protected, and public members stay public.

With private inheritance, all members from the base class are inherited as private. 
This means private members stay private, and protected and public members become private.

Protected inheritance is the last method of inheritance. It is almost never used, except in very particular cases. 
With protected inheritance, the public and protected members become protected, and private members stay private.

Default inheritance type:
It's private for class and public for struct.
the default type of the inheritance depends on the inheriting type (B), not on the one that is being inherited (A). For example:
class A {};
struct B: /* public */ A {};

struct A {};
class B: /* private */ A {};


//============================================================================
vector.push_back - Амортизированная константная сложность
//============================================================================

http://cs.stackexchange.com/questions/9380/why-is-push-back-in-c-vectors-constant-amortized

Сумма n членов геометрической прогрессии:
http://school-collection.edu.ru/catalog/res/6b075d88-01b7-4ca7-aebf-69f152868609/view/

Для grow factor = 2
чтобы вставить 2^3 + 1 элемент нужно
2^1 + 2^2 + 2^3 + 2^4 
перераспределений элементов.

Нужно посчитать сумму n членов геометрической прогрессии:
Sum = (firstElement * (base ^ n - 1))   /   (base - 1)

Для двойки и firstElement = 1:
Sum = 2 ^ n - 1

Чтобы заметить эту формулу можно посмотреть:
1 2 4 8 16 32,
т.е. сумма всех предыдущих элементов равна следующему - 1 (1 + 2 + 4 + 8 = 15 = 16-1)

Чтобы вставить 2^n + 1 елементов нужно 2^(n+1) перераспределений.
Таким образом на один элемент приходится:
2^(n+1) / 2^n + 1 ~ 2, т.е константа.


//============================================================================
name hiding, function call resolution
//============================================================================

The name resolution rules say that name lookup stops in the first scope in which a matching name is found. 
At that point, the overload resolution rules kick in to find the best match of available functions.

Если имя функции найдено в классе - ребенке, то рассматриваются только перегрузки из этого ребенка,
функции из родителя не учитываются

This is "By Design". In C++ overload resolution for this type of method works like the following.
    Starting at the type of the reference and then going to the base type, find the first type which has a method named "gogo"
    Considering only methods named "gogo" on that type find a matching overload
   

//============================================================================
sizeof 
//============================================================================

sizeof(expression)

sizeof не выполняет выражение. Только по выражению определяет тип.
Все полностью считается во время компиляции.
Скобки ставить не обязательно, т.е. можно: sizeof expression
   

Размер пустого объекта без данных 1 байт.
Если массив таких объектов, то по одному байту на элемент.

Если в классе указано поле const, то это поле занимает место во всех экземплярах класса,
т.е. это обычное поле данных, которое нельзя менять.

//============================================================================
Exception safety guarantees   
//============================================================================

* No-throw guarantee, also known as failure transparency: Operations are guaranteed to succeed and satisfy all requirements even in exceptional situations. 
  If an exception occurs, it will be handled internally and not observed by clients.
* Strong exception safety, also known as commit or rollback semantics: Operations can fail, 
  but failed operations are guaranteed to have no side effects, so all data retain their original values.[4]
* Basic exception safety, also known as a no-leak guarantee: Partial execution of failed operations can cause side effects, 
  but all invariants are preserved and there are no resource leaks (including memory leaks). 
  Any stored data will contain valid values, even if they differ from what they were before the exception.
* No exception safety: No guarantees are made.


//============================================================================   
static_assert
//============================================================================

//самодельный static_assert:

template<bool x> struct StaticAssertion;
template<> struct StaticAssertion<true> {};
#define PIRE_STATIC_ASSERT(x) \
enum { PireStaticAssertion ## __LINE__ = sizeof(StaticAssertion<(bool) (x)>) }

PIRE_STATIC_ASSERT(std::is_copy_constructible<Data>::value);


//стандартный static_assert:

static_assert(std::is_copy_constructible<Data>::value, "Data is not copy constructible");


//============================================================================
live lock
//============================================================================

A livelock is similar to a deadlock, except that the state of the two processes involved in the livelock 
constantly changes with regards to the other process. As a real world example, livelock occurs when two people meet in a narrow corridor, 
and each tries to be polite by moving aside to let the other pass, 
but they end up swaying from side to side without making any progress because they always both move the same way at the same time. 
A deadlock results in an infinite wait whereas a livelock results in wasting CPU cycles.


//============================================================================
starvation
//============================================================================

Starvation describes a situation where a thread is unable to gain regular access to shared resources and is unable to make progress. 
This happens when shared resources are made unavailable for long periods by "greedy" threads. For example, 
suppose an object provides a synchronized method that often takes a long time to return. 
If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.

Starvation is usually caused by an overly simplistic scheduling algorithm. 
For example, if a (poorly designed) multi-tasking system always switches between the first two tasks 
while a third never gets to run, then the third task is being starved of CPU time.

A high priority process A will run before a low priority process B. 
If the high priority process (process A) never blocks, the low priority process (B) will (in some systems) never be scheduled—it will experience starvation. 
If there is an even higher priority process X, which is dependent on a result from process B, 
then process X might never finish, even though it is the most important process in the system. This condition is called a priority inversion.


//============================================================================
thread_local
//============================================================================

thread_local переменные адресуются через регистр fs.
У каждого потока в регистре свой адрес.
Обращение к thread_local переменным с такой же скоростью как к обычным переменным.

int thread_local_accum(int x)
{
    thread_local int accum = 0;    
    
    accum += x;
    
    return accum;
}

thread_local_accum(int):
3	{

4	    thread_local int accum = 0;    
5	    
6	    accum += x;
=> 0x00000000004015c0 <+0>:	64 8b 04 25 fc ff ff ff	mov    eax,DWORD PTR fs:0xfffffffffffffffc
   0x00000000004015c8 <+8>:	01 f8	add    eax,edi
   0x00000000004015ca <+10>:	64 89 04 25 fc ff ff ff	mov    DWORD PTR fs:0xfffffffffffffffc,eax

7	    
8	    return accum;
9	}
   0x00000000004015d2 <+18>:	c3	ret    

   
Реализация pthread_self:
        26 [1]	in pthread_self.c
0x7ffff78c18f0                   64 48 8b 04 25 10 00 00 00  mov    %fs:0x10,%rax
        27 [1]	in pthread_self.c
0x7ffff78c18f9  <+0x0009>        c3                          retq   


std::thread::id tid = std::this_thread::get_id();
Тоже вызывает pthread_self


//============================================================================
load so ld _dl_runtime_resolve
//============================================================================

Функции из so резолвятся только при первом обращении.
Чтобы сразу зарезолвить все функции (полезно для debugger-a) нужно определить в environment
LD_BIND_NOW=y
(y - любая не пустая строка)

man ld.so



//============================================================================
exception handling internals
//============================================================================

https://monoinfinito.wordpress.com/series/exception-handling-in-c/
http://mentorembedded.github.io/cxx-abi/
http://libcxxabi.llvm.org/spec.html
https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v01

source for libstdc++:
https://github.com/gcc-mirror/gcc

*    When we write a throw statement, the compiler will translate it into a pair of calls into libstdc++ functions 
     that allocate the exception and then start the stack unwinding process by calling libstdc.
*    For each catch statement, the compiler will write some special information after the method’s body, 
     a table of exceptions this method can catch and a cleanup table (more on the cleanup table later).
*    As the unwinder goes through the stack it will call a special function provided by libstdc++ (called personality routine) 
     that checks for each function in the stack which exceptions can be caught.
*    If no matching catch is found for the exception, std::terminate is called.
*    If a matching catch is found, the unwinder now starts again on the top of the stack.
*    As the unwinder goes through the stack a second time it will ask the personality routine to perform a cleanup for this method.
*    The personality routine will check the cleanup table on the current method. If there are any cleanup actions to be run, 
     it will “jump” into the current stack frame and run the cleanup code. This will run the destructor for each object allocated at the current scope.
*    Once the unwinder reaches the frame in the stack that can handle the exception it will jump into the proper catch statement.
*    Upon finishing the execution of the catch statement, a cleanup function will be called to release the memory held for the exception.

ABI - application binary interface

__cxa_allocate_exception receives a size_t and allocates enough memory to hold the exception being thrown
most implementations seem to allocate memory on a local thread storage (heap) but resort to an emergency storage (presumably static) if out of memory.

__cxa_throw - function is responsible of starting the stack unwinding.
__cxa_throw is never supposed to return. It either delegates execution to the correct catch block to handle the exception 
or calls (by default) std::terminate, but it never ever returns.

vtable for __cxxabiv1::__class_type_info - this is the entry point the ABI defines to know (in runtime) whether two types are the same or not




//============================================================================
Разное
//============================================================================
vector<bool> - специализация, использует один бит для значения. Лучше не использовать.

Boost.Lockfree:
The C++ exception handling does not give any guarantees about its real-time behavior. We therefore do not encourage the use of exceptions and exception handling in lock-free code. 

Lock free containers: Boost.Lockfree
boost::lockfree::queue
boost::lockfree::stack
boost::lockfree::spsc_queue


c++ string formatters:
http://www.gotw.ca/publications/mill19.htm


call function of base class from derived:
BaseClassName::functionName();


Массив объектов - не важно new или на стеке или в памяти
конструкторы вызываются от первого объекта к последнему,
деструкторы в обратном порядке - от последнего объекта к первому. 

В g++ для стабильной сортировки используется merge sort и insertion_sort:

if (__last - __first < 15)
{
  std::__insertion_sort(__first, __last, __comp);
}
else
{
    merge_sort
}

Для merge_sort используется временный буфер stl_tempbuf.h
Если буфер не получилось выделить - делается merge без буфера.

Размер классов:
learn_other.cpp

sizeof(DataChar) = 1
sizeof(DataIntChar) = 8
sizeof(DataCharInt) = 8
sizeof(DataCharIntChar) = 12

Т.е. размер класса округляется вверх до следующего выравненного значения.


class should manage one resource only!


Deque complexity:
    Random access - constant O(1)
    Insertion or removal of elements at the end or beginning - constant O(1)
    Insertion or removal of elements - linear O(n) 
    
Чтобы ограничить видимость функции или переменной или типа текущим файлом
вместо static перед функцией (как было в С) нужно использовать анонимные namespace:
namespace {
    int cannotAccessOutsideThisFile() { ... }
}       
Все объявленное внутри такого namespace доступно только в текущем файле и не будет ошибок линковки если такие имена уже есть в программе.


In C++, if the types of two operands differ from one another, 
then the operand with the “lower type” will be promoted to the type of the “higher type” operand, 
using the following type hierarchy (listed here from highest type to lowest type): 
long double, double, float, unsigned long int, long int, unsigned int, int (lowest).
Moreover, the result of the operation will be of the type of the operands.
cout << 25u - 50;  ==  4294967271

Определение, что класс является родителем данного:
std::cout << "A, B: " << std::is_base_of<A,B>::value << std::endl;
Если писать шаблон самому, то нужно через перегрузку функций и sizeof (https://www.toptal.com/c-plus-plus/interview-questions)


Определение, что класс является родителем данного:
template<typename D, typename B>
class IsDerivedFromHelper
{
    class No { };
    class Yes { No no[3]; };
    
    static Yes Test( B* );
    static No Test( ... );
public:
    enum { Is = sizeof(Test(static_cast<D*>(0))) == sizeof(Yes) };
    
};

template <class C, class P> 
bool IsDerivedFrom() {
    return IsDerivedFromHelper<C, P>::Is;
}

Определение, что A и B это один класс:
template <typename T, typename U>
struct is_same
{
    static const bool value = false;
};

template <typename T>
struct is_same<T, T>
{
    static const bool value = true;
};

template <class A, class B>
bool IsSameClass() {
    return is_same<A, B>::value;
}


if control leaves a destructor due to an exception while another exception is active, C++ calls the terminate function.


(1+3)[a] is the same as a[1+3]
Можно писать так:
int a[] = {1, 2, 3, 4, 5, 6};
std::cout << (1 + 3)[a] - a[0] + (a + 1)[2];

Volatile
The volatile keyword informs the compiler that a variable will be used by multiple threads. Variables that are declared as volatile will not be cached by the compiler to ensure the most up-to-date value is held.

Mutable
The mutable keyword can be used for class member variables. Mutable variables are allowed to change from within const member functions of the class.


Полиморфизм - единообразная обработка разнотипных данных.


Если есть ссылка 
MyExceptionA &e;
throw e;
При throw вызывается конструктор копий для MyExceptionA, даже если ссылка указывает на ребенка.

}catch(MyExceptionA &ex){        
    cout <<"catch MyExceptionA: "<< ex.getMessage()<<endl;
    //throw ex; //1
    throw;      //2
}

Если написано //1, то будет выброшен тип MyExceptionA, даже если &ex указывает на ребенка (будет вызван конструктор копий).
Если написано //2, то будет выброшено то исключение, которое было изначально.


