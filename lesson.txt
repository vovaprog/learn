+ Список контейнеров STL
+ priority_queue
+ Алгоритмическая сложность контейнеров STL
+ Преобразования типов
+ RTTI
+ size_t
+ default, delete functions
+ special member functions
+ move semantics
+ function call resolution
+ traits
+ multimap/multiset
+ priority_queue
+ const pointer and pointer to const
+ posix processes
posix threads
Copy-and-swap
tcp/ip levels
posix functions
socket functions
unicode

//debian install updates:
apt-get dist-upgrade

//============================================================================
Список контейнеров STL
//============================================================================

Sequence containers
array
vector
deque
list
forward_list

Associative containers
set
map
multiset
multimap

Unordered associative containers
unordered_set
unordered_map
unordered_multiset
unordered_multimap

Container adaptors
stack
queue
priority_queue


//============================================================================
priority_queue
//============================================================================
make_heap
push_heap
pop_heap

push O(log n)	
top O(1)	
pop O(log n)

Binary heap
https://en.wikipedia.org/wiki/Binary_heap

A binary heap is a heap data structure created using a binary tree. It can be seen as a binary tree with two additional constraints:[1]
Shape property
    A binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.
Heap property
    All nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison predicate defined for the heap. 

    Значение в любой вершине не меньше, чем значения её потомков.
    Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.
    Последний слой заполняется слева направо.
    
    
//============================================================================    
Алгоритмическая сложность контейнеров STL    
//============================================================================

http://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html    


//============================================================================
Преобразования типов
//============================================================================

dynamic_cast
Оператор dynamic_cast может быть применён к указателям или ссылкам.
Обязательно в классе источнике должна быть virtual функция!!!
НЕ обязательно источник и target должны быть в одной иерархии наследования.
В случае если осуществляется преобразование указателя к типу данных, который не является фактическим типом объекта, 
в результате преобразования будет получен нулевой указатель. 
При работе со ссылками при невозможности преобразования типа будет сгенерировано исключение std::bad_cast.
Механизм динамической идентификации типа данных доступен только для полиморфных 
классов (т.е. классов, содержащих хотя бы одну виртуальную функцию-член)


c style cast
http://en.cppreference.com/w/cpp/language/explicit_cast
http://stackoverflow.com/questions/13960939/reinterpret-cast-vs-c-style-cast

A C-style cast is equivalent to the first of the following that succeeds:
    a const_cast
    a static_cast
    a static_cast followed by const_cast
    a reinterpret_cast
    a reinterpret_cast followed by const_cast

When the C-style cast expression is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:
a) const_cast<new_type>(expression);
b) static_cast<new_type>(expression), with extensions: pointer or reference to a derived class is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is inaccessible (that is, this cast ignores the private inheritance specifier). Same applies to casting pointer to member to pointer to member of unambigous non-virtual base;
c) static_cast (with extensions) followed by const_cast;
d) reinterpret_cast<new_type>(expression);
e) reinterpret_cast followed by const_cast.
The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). 
If the cast can be interpreted in more than one way as static_cast followed by a const_cast, it cannot be compiled.
    
    
    
static_cast
http://en.cppreference.com/w/cpp/language/static_cast
The type parameter must be a data type for which there is a known method for converting object to, whether this be a builtin or through a casting function.
All types of conversions that are well-defined and allowed by the compiler are done using static_cast.
The static_cast operator can be used for operations such as

    Converting a pointer of a base class to a pointer of a derived class,
    Convert numeric data types such as enums to ints or ints to floats.

However, static_cast conversions are not necessarily safe as no run-time type check is done which can cause casting between incompatible data types, 
for example pointers. 
However, this is checked at compile time to prevent casting obvious incompatibles. 
Also, static_cast between pointer of a virtual base to pointer of derived is not allowed, because of the object layout model.
Если это встроенные типы, то будут использованы встроенные в C++ правила их приведения. 
Если это типы, определенные программистом, то будут использованы правила приведения, определенные программистом.
возможно такое приведение: static_cast<Derived*>(pBase), даже если pBase не указывает на Derived, но после этого поведение программы не определено.
Обычно static_cast используется, когда требуется преобразовать числовые типы данных, например перечисления в целые числа или целые числа в числа с плавающей запятой, 
и при полной уверенности в том, какие типы данных используются в преобразовании.

 If new_type is a pointer or reference to some class D and the type of expression is a pointer or reference to its non-virtual base B, 
 static_cast performs a downcast. Such static_cast makes no runtime checks to ensure that the object's runtime type is actually D

static_cast можно от родителя делать сына. Одного сына преобразовать в другого нельзя. 
static_cast нельзя pointer превращать в int и наоборот.

int intVal = reinterpret_cast<int>(pointer); error: cast from ‘Dog*’ to ‘int’ loses precision
int intVal = (int)pd; error: cast from ‘Dog*’ to ‘int’ loses precision

reinterpret_cast НЕ может убрать const.

        //iVal = reinterpret_cast<int>(longlongVal); //error
        iVal = static_cast<int>(longlongVal);        //Ok
        //longlongVal = reinterpret_cast<long long int>(iVal); //error
        //floatVal = reinterpret_cast<float>(iVal); //error
        //uiVal = reinterpret_cast<unsigned int>(iVal); //error


Резюме:

   * static_cast - допустимые приведения времени компиляции. Можно неправильно преобразовать parent в неправильного child.
   * dynamic_cast - source только указатель или ссылка на тип с virtual функциями. 
НЕ обязательно источник и target должны быть в одной иерархии наследования.
Неправильное преобразование указатель - nullptr, ссылка - exception std::bad_cast.
   * reinterpret_cast - любые преобразования. НЕ может убирать const. Не может loses precision. Не преобразует значения разных базовых типов.
   * const_cast - убирает const.

   
//============================================================================
RTTI
//============================================================================

typeid()
The header <typeinfo> must be included before using typeid.
Можно использовать на любых типах - полиморфных, обычных, базовых.
Если тип не полиморфный - то возвращается static информация во время компиляции.
Полиморфный typeid можно использовать на указателях и ссылках.

Возвращает std::type_info
operator==
operator!=
hash_code
name
before       (checks whether the referred type precedes referred type of another type_index object in the implementation defined order, i.e. orders the referred types)

std::type_index (C++11)
The type_index class is a wrapper class around a std::type_info object, that can be used as index in associative and unordered associative containers.
operator==
operator!=
operator<
operator<=
operator>
operator>=
hash_code
name


//============================================================================
size_t
//============================================================================
It is a type able to represent the size of any object in bytes
Ubuntu64 g++ sizeof(size_t)==8


//============================================================================
default, delete functions
//============================================================================

You can delete special member functions as well as normal member functions and non-member functions to prevent them from being defined or called.

deleted functions still participate in overload resolution. 
The function call resolves to the more-specific—but deleted—function and causes a compiler error.

Function that can be called only with double argument:
template < typename T >
void call_with_true_double_only(T) =delete; //prevent call through type promotion of any T to double from succeeding.
void call_with_true_double_only(double param) { return; } // also define for const double, double&, etc. as needed.


//============================================================================
special member functions
//============================================================================
Special member functions in C++ are functions which the compiler will automatically generate if they are used, but not declared explicitly by the programmer.

C++ has six kinds of special member functions:
*Default constructors   ( if no other constructor is explicitly declared )
*Destructors
*Copy constructors          (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy constructor is deprecated)
*Copy assignment operators  (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy assignment operator is deprecated.) 
*Move constructors          (if no copy constructor, copy assignment operator, move assignment operator and destructor are explicitly declared.)
*Move assignment operators  (if no copy constructor, copy assignment operator, move constructor and destructor are explicitly declared.)

Signatures:
Default constructor 	MyClass();
Copy constructor 	MyClass(const MyClass& other);
Move constructor 	MyClass(MyClass&& other) noexcept;
Copy assignment operator 	MyClass& operator=(const MyClass& other);
Move assignment operator 	MyClass& operator=(MyClass&& other) noexcept;
Destructor 	~MyClass();


//============================================================================
move semantics
//============================================================================
http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html

return value optimization
return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function's return value.
https://en.wikipedia.org/wiki/Return_value_optimization
https://en.wikipedia.org/wiki/Copy_elision
https://en.wikipedia.org/wiki/As-if_rule

The standard for the C++ programming language allows compilers for this language to apply any optimizating transformation to a program during compilation, 
provided that such optimizations make no change in the "observable behavior" of the program, as specified in the standard; 
this mostly means that any actions the program performs on its environment occur in the specified order. 
This rule is commonly referred to as the as-if rule.
The rule has three main exceptions. The first is that programs exhibiting undefined behavior are exempt; 
since the observable behavior is not well-defined anyway, any transformation is valid. 
The other two exceptions concern the copying of objects, and are called copy elision and the return value optimization.

move semantics позволяет хранить в stl контейнерах некопируемые объекты.
https://habrahabr.ru/post/174019/


//============================================================================
function call resolution
//============================================================================

Argument-dependent lookup
http://en.cppreference.com/w/cpp/language/adl
Argument-dependent lookup, also known as ADL, or Koenig lookup, 
is the set of rules for looking up the unqualified function names in function-call expressions, 
including implicit function calls to overloaded operators. 
These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces 
considered by the usual unqualified name lookup. 
Argument-dependent lookup makes it possible to use operators defined in a different namespace.

Template argument deduction
http://en.cppreference.com/w/cpp/language/template_argument_deduction
In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. 
When possible, the compiler will deduce the missing template arguments from the function arguments.


//============================================================================
unicode
//============================================================================

character type sizes - look in small_progs/type_limits.cpp


//============================================================================
traits
//============================================================================
small_progs/type_limits.cpp

https://erdani.com/publications/traits.html

traits are important because they allow you to make compile-time decisions based on types, 
much as you would make runtime decisions based on values.

Traits rely on explicit template specialization to pull out type-related variations from code, and to wrap them under a uniform interface.

A traits template is a template class, possibly explicitly specialized, 
that provides a uniform symbolic interface over a coherent set of design choices that vary from one type to another.


//============================================================================
multimap multiset
//============================================================================

learn_algorithms/codeforces_archive/659b_multimap.cpp
learn_algorithms/codeforces_archive/659b_multiset.cpp
small_progs/learn_multimap_multiset.cpp

multimap<string,string> mm;

//insert
mm.insert(make_pair("key1","val11"));
mm.emplace("key1","val12");

//iterate
for(auto &p : mm)
{
	cout <<p.first<<" "<<p.second<<endl;	    	
}
cout <<mm.begin()->first<<endl;   


//get elements by key (p is pair - first, second)
auto p = mm.equal_range(key); 
    
for(auto it=p.first;it!=p.second;++it)
{
	cout <<it->second<<endl;	
}

//get number of found items:
cout <<"number of items: "<<distance(p.first,p.second)<<endl;

//erase
int removedCount = mm.erase(key); //Return value Number of elements removed.
auto p2 = mm.equal_range(key);
mm.erase(p2.first,p2.second); //Return value  Iterator following the last removed element.
auto p2 = mm.equal_range(key);
mm.erase(p2.first); //Return value  Iterator following the last removed element.

//number of elements with specific key:
mm.count(key);

//number of elements
mm.size();


//============================================================================
priority_queue
//============================================================================

default container - class Container = vector<T>

const_reference top() const;
void pop();
void push (const value_type& val);
template <class... Args> void emplace (Args&&... args);

    //=================== priority queue ==========================    
    priority_queue<string> q;
    q.push("hello");
    q.emplace("world");
    q.push("program");
    cout <<q.top()<<" "<<q.top()<<q.size()<<endl;
    q.pop();
    cout <<q.top()<<" "<<q.top()<<q.size()<<endl;    
    //=================== priority queue ==========================


//============================================================================    
const pointer and pointer to const    
//============================================================================    

Если слово const перед звездочкой (не важно перед или после int) - то
это изменяемый указатель на константные данные.
Сам указатель константный только если const стоит после звездочки.

int const * - pointer to const int
int * const - const pointer to int
int const * const - const pointer to const int

Now the first const can be on either side of the type so:
    const int * == int const *
    const int * const == int const * const


//============================================================================
posix processes
//============================================================================

show all processes on system:
ps -e

send program SIGTERM signal
kill
kill (child_pid, SIGTERM);

Получить номера сигналов:
/bin/kill --table
 1 HUP      2 INT      3 QUIT     4 ILL      5 TRAP     6 ABRT     7 BUS
 8 FPE      9 KILL    10 USR1    11 SEGV    12 USR2    13 PIPE    14 ALRM
15 TERM    16 STKFLT  17 CHLD    18 CONT    19 STOP    20 TSTP    21 TTIN
22 TTOU    23 URG     24 XCPU    25 XFSZ    26 VTALRM  27 PROF    28 WINCH
29 POLL    30 PWR     31 SYS     

//------------------------------------------------

system creates a subprocess running the standard Bourne shell (/bin/sh)
and hands the command to that shell for execution
return_value = system ("ls -l /");

//------------------------------------------------

fork:
learn_system.cpp

pid_t result=fork();
if(result==0)
{
	cout <<"child"<<endl;
}
else if(result>0)
{
	cout <<"parent"<<endl;	
}
else
{
	cout <<"error!"<<endl;    
}

//------------------------------------------------

exec:
int result = execlp("echo","echo","hello!","world!",NULL);
cout <<"exec failed! "<<result<<endl;

//------------------------------------------------

nice - set process priority
program and function
больше nice - меньше priority
Niceness values range from -20 (most favorable to the process) to 19 (least favorable to the process).
nice()  adds  inc to the nice value for the calling process.  (A higher nice value means a low priority.)  Only the
superuser may specify a negative increment, or priority increase.

int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int prio);

//------------------------------------------------

signals:
you should avoid performing any I/O operations or calling most library
and system functions from signal handlers. In
most cases, this consists simply of recording the fact that a signal occurred.The main
program then checks periodically whether a signal has occurred and reacts accordingly.

The SIGTERM
signal asks a process to terminate; the process may
ignore the request by masking or ignoring the signal.
The SIGKILL signal always kills the process
immediately because the process may not mask or ignore  SIGKILL

signal(SIGINT,sig_int_handler);
void sig_int_handler(int i)
{ 
    printf("sig int handler\r\n");
    exit(-1);
}
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

sig_atomic_t sigusr1_count = 0;
void handler (int signal_number)
{
	++sigusr1_count;
}
struct sigaction sa;
memset (&sa, 0, sizeof (sa));
sa.sa_handler = &handler;
sigaction (SIGUSR1, &sa, NULL);
printf (“SIGUSR1 was raised %d times\n”, sigusr1_count);

ожидать завершения ребенка:
int child_status;
wait (&child_status);
if (WIFEXITED (child_status))
	printf (“the child process exited normally, with exit code %d\n”,WEXITSTATUS (child_status));
else
	printf (“the child process exited abnormally\n”);

Также waitpid, waitid.

A zombie process is a process that has terminated but has not been cleaned up yet (wait не была вызвана).

When a program exits, its children are inherited by a special process, the init program, which
always runs with process ID of 1 (it ’s the first process started when Linux boots).The init
process automatically cleans up any zombie child processes that it inherits.

wait3 or wait4 have parameter not to wait, immediately return if no child events exist.
When a child process terminates, Linux sends the parent process the SIGCHLD signal.
an easy way to clean up child processes is by handling SIGCHLD


//============================================================================
posix threads
//============================================================================
//нужно добавлять библиотеку:
g++ -lpthread

pthread_create
pthread_join(thread_handle,(void**)&thread_result);

The pthread_self function returns the thread ID of the thread in which it is called

A joinable thread, like a process, is not automatically cleaned up by GNU/Linux when it terminates. 
Instead, the thread’s exit
state hangs around in the system (kind of like a zombie process) until another thread
calls pthread_join to obtain its return value. Only then are its resources released.

A detached thread, in contrast, is cleaned up automatically when it terminates. 

Create detached thread:
pthread_attr_t attr;
pthread_attr_init (&attr);
pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);	
pthread_create (&thread, &attr, &thread_function, NULL);
pthread_attr_destroy (&attr);

Set thread to detached mode after creation: call pthread_detach


