+ Список контейнеров STL
+ priority_queue
+ Алгоритмическая сложность контейнеров STL
+ Преобразования типов
+ RTTI
+ size_t
+ default, delete functions
+ special member functions
+ move semantics
+ function call resolution
+ traits
Copy-and-swap
const pointer and pointer to const
tcp/ip levels
multimap/multiset
posix functions
socket functions
unicode


//============================================================================
Список контейнеров STL
//============================================================================

Sequence containers
array
vector
deque
list
forward_list

Associative containers
set
map
multiset
multimap

Unordered associative containers
unordered_set
unordered_map
unordered_multiset
unordered_multimap

Container adaptors
stack
queue
priority_queue


//============================================================================
priority_queue
//============================================================================
make_heap
push_heap
pop_heap

push O(log n)	
top O(1)	
pop O(log n)

Binary heap
https://en.wikipedia.org/wiki/Binary_heap

A binary heap is a heap data structure created using a binary tree. It can be seen as a binary tree with two additional constraints:[1]
Shape property
    A binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.
Heap property
    All nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison predicate defined for the heap. 

    Значение в любой вершине не меньше, чем значения её потомков.
    Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.
    Последний слой заполняется слева направо.
    
    
//============================================================================    
Алгоритмическая сложность контейнеров STL    
//============================================================================

http://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html    


//============================================================================
Преобразования типов
//============================================================================

dynamic_cast
Оператор dynamic_cast может быть применён к указателям или ссылкам.
Обязательно в классе источнике должна быть virtual функция!!!
НЕ обязательно источник и target должны быть в одной иерархии наследования.
В случае если осуществляется преобразование указателя к типу данных, который не является фактическим типом объекта, 
в результате преобразования будет получен нулевой указатель. 
При работе со ссылками при невозможности преобразования типа будет сгенерировано исключение std::bad_cast.
Механизм динамической идентификации типа данных доступен только для полиморфных 
классов (т.е. классов, содержащих хотя бы одну виртуальную функцию-член)


c style cast
http://en.cppreference.com/w/cpp/language/explicit_cast
http://stackoverflow.com/questions/13960939/reinterpret-cast-vs-c-style-cast

A C-style cast is equivalent to the first of the following that succeeds:
    a const_cast
    a static_cast
    a static_cast followed by const_cast
    a reinterpret_cast
    a reinterpret_cast followed by const_cast

When the C-style cast expression is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:
a) const_cast<new_type>(expression);
b) static_cast<new_type>(expression), with extensions: pointer or reference to a derived class is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is inaccessible (that is, this cast ignores the private inheritance specifier). Same applies to casting pointer to member to pointer to member of unambigous non-virtual base;
c) static_cast (with extensions) followed by const_cast;
d) reinterpret_cast<new_type>(expression);
e) reinterpret_cast followed by const_cast.
The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). 
If the cast can be interpreted in more than one way as static_cast followed by a const_cast, it cannot be compiled.
    
    
    
static_cast
http://en.cppreference.com/w/cpp/language/static_cast
The type parameter must be a data type for which there is a known method for converting object to, whether this be a builtin or through a casting function.
All types of conversions that are well-defined and allowed by the compiler are done using static_cast.
The static_cast operator can be used for operations such as

    Converting a pointer of a base class to a pointer of a derived class,
    Convert numeric data types such as enums to ints or ints to floats.

However, static_cast conversions are not necessarily safe as no run-time type check is done which can cause casting between incompatible data types, 
for example pointers. 
However, this is checked at compile time to prevent casting obvious incompatibles. 
Also, static_cast between pointer of a virtual base to pointer of derived is not allowed, because of the object layout model.
Если это встроенные типы, то будут использованы встроенные в C++ правила их приведения. 
Если это типы, определенные программистом, то будут использованы правила приведения, определенные программистом.
возможно такое приведение: static_cast<Derived*>(pBase), даже если pBase не указывает на Derived, но после этого поведение программы не определено.
Обычно static_cast используется, когда требуется преобразовать числовые типы данных, например перечисления в целые числа или целые числа в числа с плавающей запятой, 
и при полной уверенности в том, какие типы данных используются в преобразовании.

 If new_type is a pointer or reference to some class D and the type of expression is a pointer or reference to its non-virtual base B, 
 static_cast performs a downcast. Such static_cast makes no runtime checks to ensure that the object's runtime type is actually D

static_cast можно от родителя делать сына. Одного сына преобразовать в другого нельзя. 
static_cast нельзя pointer превращать в int и наоборот.

int intVal = reinterpret_cast<int>(pointer); error: cast from ‘Dog*’ to ‘int’ loses precision
int intVal = (int)pd; error: cast from ‘Dog*’ to ‘int’ loses precision

reinterpret_cast НЕ может убрать const.

        //iVal = reinterpret_cast<int>(longlongVal); //error
        iVal = static_cast<int>(longlongVal);        //Ok
        //longlongVal = reinterpret_cast<long long int>(iVal); //error
        //floatVal = reinterpret_cast<float>(iVal); //error
        //uiVal = reinterpret_cast<unsigned int>(iVal); //error


Резюме:

   * static_cast - допустимые приведения времени компиляции. Можно неправильно преобразовать parent в неправильного child.
   * dynamic_cast - source только указатель или ссылка на тип с virtual функциями. 
НЕ обязательно источник и target должны быть в одной иерархии наследования.
Неправильное преобразование указатель - nullptr, ссылка - exception std::bad_cast.
   * reinterpret_cast - любые преобразования. НЕ может убирать const. Не может loses precision. Не преобразует значения разных базовых типов.
   * const_cast - убирает const.

   
//============================================================================
RTTI
//============================================================================

typeid()
The header <typeinfo> must be included before using typeid.
Можно использовать на любых типах - полиморфных, обычных, базовых.
Если тип не полиморфный - то возвращается static информация во время компиляции.
Полиморфный typeid можно использовать на указателях и ссылках.

Возвращает std::type_info
operator==
operator!=
hash_code
name
before       (checks whether the referred type precedes referred type of another type_index object in the implementation defined order, i.e. orders the referred types)

std::type_index (C++11)
The type_index class is a wrapper class around a std::type_info object, that can be used as index in associative and unordered associative containers.
operator==
operator!=
operator<
operator<=
operator>
operator>=
hash_code
name


//============================================================================
size_t
//============================================================================
It is a type able to represent the size of any object in bytes
Ubuntu64 g++ sizeof(size_t)==8


//============================================================================
default, delete functions
//============================================================================

You can delete special member functions as well as normal member functions and non-member functions to prevent them from being defined or called.

deleted functions still participate in overload resolution. 
The function call resolves to the more-specific—but deleted—function and causes a compiler error.

Function that can be called only with double argument:
template < typename T >
void call_with_true_double_only(T) =delete; //prevent call through type promotion of any T to double from succeeding.
void call_with_true_double_only(double param) { return; } // also define for const double, double&, etc. as needed.


//============================================================================
special member functions
//============================================================================
Special member functions in C++ are functions which the compiler will automatically generate if they are used, but not declared explicitly by the programmer.

C++ has six kinds of special member functions:
*Default constructors   ( if no other constructor is explicitly declared )
*Destructors
*Copy constructors          (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy constructor is deprecated)
*Copy assignment operators  (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy assignment operator is deprecated.) 
*Move constructors          (if no copy constructor, copy assignment operator, move assignment operator and destructor are explicitly declared.)
*Move assignment operators  (if no copy constructor, copy assignment operator, move constructor and destructor are explicitly declared.)

Signatures:
Default constructor 	MyClass();
Copy constructor 	MyClass(const MyClass& other);
Move constructor 	MyClass(MyClass&& other) noexcept;
Copy assignment operator 	MyClass& operator=(const MyClass& other);
Move assignment operator 	MyClass& operator=(MyClass&& other) noexcept;
Destructor 	~MyClass();


//============================================================================
move semantics
//============================================================================
http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html

return value optimization
return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function's return value.
https://en.wikipedia.org/wiki/Return_value_optimization
https://en.wikipedia.org/wiki/Copy_elision
https://en.wikipedia.org/wiki/As-if_rule

The standard for the C++ programming language allows compilers for this language to apply any optimizating transformation to a program during compilation, 
provided that such optimizations make no change in the "observable behavior" of the program, as specified in the standard; 
this mostly means that any actions the program performs on its environment occur in the specified order. 
This rule is commonly referred to as the as-if rule.
The rule has three main exceptions. The first is that programs exhibiting undefined behavior are exempt; 
since the observable behavior is not well-defined anyway, any transformation is valid. 
The other two exceptions concern the copying of objects, and are called copy elision and the return value optimization.

move semantics позволяет хранить в stl контейнерах некопируемые объекты.
https://habrahabr.ru/post/174019/


//============================================================================
function call resolution
//============================================================================

Argument-dependent lookup
http://en.cppreference.com/w/cpp/language/adl
Argument-dependent lookup, also known as ADL, or Koenig lookup, 
is the set of rules for looking up the unqualified function names in function-call expressions, 
including implicit function calls to overloaded operators. 
These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces 
considered by the usual unqualified name lookup. 
Argument-dependent lookup makes it possible to use operators defined in a different namespace.

Template argument deduction
http://en.cppreference.com/w/cpp/language/template_argument_deduction
In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. 
When possible, the compiler will deduce the missing template arguments from the function arguments.


//============================================================================
unicode
//============================================================================

character type sizes - look in small_progs/type_limits.cpp


//============================================================================
traits
//============================================================================
https://erdani.com/publications/traits.html
In short, traits are important because they allow you to make compile-time decisions based on types, 
much as you would make runtime decisions based on values. 
Better still, by adding the proverbial "extra level of indirection" that solves many software engineering problems, 
traits let you take the type decisions out of the immediate context where they are made. 
This makes the resulting code cleaner, more readable, and easier to maintain. 
If you apply traits correctly, you get these advantages without paying the cost in performance, safety, or coupling that other solutions might exact. 

sample implementation:
small_progs/type_limits.cpp


