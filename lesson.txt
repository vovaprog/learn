+ Список контейнеров STL
+ priority_queue
+ Алгоритмическая сложность контейнеров STL
+ Преобразования типов
+ RTTI
+ size_t
+ default, delete functions
+ special member functions
+ move semantics
+ function call resolution
+ traits
+ multimap/multiset
+ priority_queue
+ const pointer and pointer to const
+ posix processes
+ posix threads
+ posix ipc
+ stl and thread safety
+ c++11 threads
+ c++11 futures
+ sockets
+ tcp/ip levels
+ raw sockets
+ poll/select
паттерны проектирования
исключения  
smart pointers
nothrow new, placement new
шаблоны
none type template parameters (int double какие допустимы)


//------------
виртуальный деструктор
статический полиморфизм
undefined/unspecified behavior
cast
smart pointers (где лежит указатель на объект в control block или в самом объекте, какие операции потоко безопасны)
make_shared
weak_ptr
nothrow new
placement new
исключения
исключение в деструкторе
порядок catch блоков
Майерс исключения
как ловить по значению или по ссылке (по ссылке)
где лежит объект исключения
внутреннее устройство исключений
вызов виртуальной функции в списке инициализации
сложность stable_sort
сложность вставки в vector - вывод формулы
facebook контейнеры
типы контейнеров stl
deque - сложность операций
типы хеш таблиц
insert sort
характеристики сортировок
когда создается move конструктор
правила создания стандартных функций класса
Copy-and-swap
шаблоны
none type template parameters (int double какие допустимы)
перевернуть односвязный список
cracking the coding interview
producer-consumer
//------------

unicode
Copy-and-swap
разное


//============================================================================
Список контейнеров STL
//============================================================================

Sequence containers
array
vector
deque
list
forward_list

Associative containers
set
map
multiset
multimap

Unordered associative containers
unordered_set
unordered_map
unordered_multiset
unordered_multimap

Container adaptors
stack
queue
priority_queue


//============================================================================
priority_queue
//============================================================================
make_heap
push_heap
pop_heap

push O(log n)	
top O(1)	
pop O(log n)

Binary heap
https://en.wikipedia.org/wiki/Binary_heap

A binary heap is a heap data structure created using a binary tree. It can be seen as a binary tree with two additional constraints:[1]
Shape property
    A binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.
Heap property
    All nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison predicate defined for the heap. 

    Значение в любой вершине не меньше, чем значения её потомков.
    Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.
    Последний слой заполняется слева направо.
    
    
//============================================================================    
Алгоритмическая сложность контейнеров STL    
//============================================================================

http://www.cs.northwestern.edu/~riesbeck/programming/c++/stl-summary.html    


//============================================================================
Преобразования типов
//============================================================================

dynamic_cast
Оператор dynamic_cast может быть применён к указателям или ссылкам.
Обязательно в классе источнике должна быть virtual функция!!!
НЕ обязательно источник и target должны быть в одной иерархии наследования.
В случае если осуществляется преобразование указателя к типу данных, который не является фактическим типом объекта, 
в результате преобразования будет получен нулевой указатель. 
При работе со ссылками при невозможности преобразования типа будет сгенерировано исключение std::bad_cast.
Механизм динамической идентификации типа данных доступен только для полиморфных 
классов (т.е. классов, содержащих хотя бы одну виртуальную функцию-член)


c style cast
http://en.cppreference.com/w/cpp/language/explicit_cast
http://stackoverflow.com/questions/13960939/reinterpret-cast-vs-c-style-cast

A C-style cast is equivalent to the first of the following that succeeds:
    a const_cast
    a static_cast
    a static_cast followed by const_cast
    a reinterpret_cast
    a reinterpret_cast followed by const_cast

When the C-style cast expression is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:
a) const_cast<new_type>(expression);
b) static_cast<new_type>(expression), with extensions: pointer or reference to a derived class is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is inaccessible (that is, this cast ignores the private inheritance specifier). Same applies to casting pointer to member to pointer to member of unambigous non-virtual base;
c) static_cast (with extensions) followed by const_cast;
d) reinterpret_cast<new_type>(expression);
e) reinterpret_cast followed by const_cast.
The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). 
If the cast can be interpreted in more than one way as static_cast followed by a const_cast, it cannot be compiled.
    
    
    
static_cast
http://en.cppreference.com/w/cpp/language/static_cast
The type parameter must be a data type for which there is a known method for converting object to, whether this be a builtin or through a casting function.
All types of conversions that are well-defined and allowed by the compiler are done using static_cast.
The static_cast operator can be used for operations such as

    Converting a pointer of a base class to a pointer of a derived class,
    Convert numeric data types such as enums to ints or ints to floats.

However, static_cast conversions are not necessarily safe as no run-time type check is done which can cause casting between incompatible data types, 
for example pointers. 
However, this is checked at compile time to prevent casting obvious incompatibles. 
Also, static_cast between pointer of a virtual base to pointer of derived is not allowed, because of the object layout model.
Если это встроенные типы, то будут использованы встроенные в C++ правила их приведения. 
Если это типы, определенные программистом, то будут использованы правила приведения, определенные программистом.
возможно такое приведение: static_cast<Derived*>(pBase), даже если pBase не указывает на Derived, но после этого поведение программы не определено.
Обычно static_cast используется, когда требуется преобразовать числовые типы данных, например перечисления в целые числа или целые числа в числа с плавающей запятой, 
и при полной уверенности в том, какие типы данных используются в преобразовании.

 If new_type is a pointer or reference to some class D and the type of expression is a pointer or reference to its non-virtual base B, 
 static_cast performs a downcast. Such static_cast makes no runtime checks to ensure that the object's runtime type is actually D

static_cast можно от родителя делать сына. Одного сына преобразовать в другого нельзя. 
static_cast нельзя pointer превращать в int и наоборот.

int intVal = reinterpret_cast<int>(pointer); error: cast from ‘Dog*’ to ‘int’ loses precision
int intVal = (int)pd; error: cast from ‘Dog*’ to ‘int’ loses precision

reinterpret_cast НЕ может убрать const.

        //iVal = reinterpret_cast<int>(longlongVal); //error
        iVal = static_cast<int>(longlongVal);        //Ok
        //longlongVal = reinterpret_cast<long long int>(iVal); //error
        //floatVal = reinterpret_cast<float>(iVal); //error
        //uiVal = reinterpret_cast<unsigned int>(iVal); //error


Резюме:

   * static_cast - допустимые приведения времени компиляции. Можно неправильно преобразовать parent в неправильного child.
   * dynamic_cast - source только указатель или ссылка на тип с virtual функциями. 
НЕ обязательно источник и target должны быть в одной иерархии наследования.
Неправильное преобразование указатель - nullptr, ссылка - exception std::bad_cast.
   * reinterpret_cast - любые преобразования. НЕ может убирать const. Не может loses precision. Не преобразует значения разных базовых типов.
   * const_cast - убирает const.

   
//============================================================================
RTTI
//============================================================================

typeid()
The header <typeinfo> must be included before using typeid.
Можно использовать на любых типах - полиморфных, обычных, базовых.
Если тип не полиморфный - то возвращается static информация во время компиляции.
Полиморфный typeid можно использовать на указателях и ссылках.

Возвращает std::type_info
operator==
operator!=
hash_code
name
before       (checks whether the referred type precedes referred type of another type_index object in the implementation defined order, i.e. orders the referred types)

std::type_index (C++11)
The type_index class is a wrapper class around a std::type_info object, that can be used as index in associative and unordered associative containers.
operator==
operator!=
operator<
operator<=
operator>
operator>=
hash_code
name


//============================================================================
size_t
//============================================================================
It is a type able to represent the size of any object in bytes
Ubuntu64 g++ sizeof(size_t)==8


//============================================================================
default, delete functions
//============================================================================

You can delete special member functions as well as normal member functions and non-member functions to prevent them from being defined or called.

deleted functions still participate in overload resolution. 
The function call resolves to the more-specific—but deleted—function and causes a compiler error.

Function that can be called only with double argument:
template < typename T >
void call_with_true_double_only(T) =delete; //prevent call through type promotion of any T to double from succeeding.
void call_with_true_double_only(double param) { return; } // also define for const double, double&, etc. as needed.


//============================================================================
special member functions
//============================================================================
Special member functions in C++ are functions which the compiler will automatically generate if they are used, but not declared explicitly by the programmer.

C++ has six kinds of special member functions:
*Default constructors   ( if no other constructor is explicitly declared )
*Destructors
*Copy constructors          (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy constructor is deprecated)
*Copy assignment operators  (if no move constructor and move assignment operator are explicitly declared. If a destructor is declared generation of a copy assignment operator is deprecated.) 
*Move constructors          (if no copy constructor, copy assignment operator, move assignment operator and destructor are explicitly declared.)
*Move assignment operators  (if no copy constructor, copy assignment operator, move constructor and destructor are explicitly declared.)

Signatures:
Default constructor 	MyClass();
Copy constructor 	MyClass(const MyClass& other);
Move constructor 	MyClass(MyClass&& other) noexcept;
Copy assignment operator 	MyClass& operator=(const MyClass& other);
Move assignment operator 	MyClass& operator=(MyClass&& other) noexcept;
Destructor 	~MyClass();


//============================================================================
move semantics
//============================================================================
http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html

return value optimization
return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function's return value.
https://en.wikipedia.org/wiki/Return_value_optimization
https://en.wikipedia.org/wiki/Copy_elision
https://en.wikipedia.org/wiki/As-if_rule

The standard for the C++ programming language allows compilers for this language to apply any optimizating transformation to a program during compilation, 
provided that such optimizations make no change in the "observable behavior" of the program, as specified in the standard; 
this mostly means that any actions the program performs on its environment occur in the specified order. 
This rule is commonly referred to as the as-if rule.
The rule has three main exceptions. The first is that programs exhibiting undefined behavior are exempt; 
since the observable behavior is not well-defined anyway, any transformation is valid. 
The other two exceptions concern the copying of objects, and are called copy elision and the return value optimization.

move semantics позволяет хранить в stl контейнерах некопируемые объекты.
https://habrahabr.ru/post/174019/


//============================================================================
function call resolution
//============================================================================

Argument-dependent lookup
http://en.cppreference.com/w/cpp/language/adl
Argument-dependent lookup, also known as ADL, or Koenig lookup, 
is the set of rules for looking up the unqualified function names in function-call expressions, 
including implicit function calls to overloaded operators. 
These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces 
considered by the usual unqualified name lookup. 
Argument-dependent lookup makes it possible to use operators defined in a different namespace.

Template argument deduction
http://en.cppreference.com/w/cpp/language/template_argument_deduction
In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. 
When possible, the compiler will deduce the missing template arguments from the function arguments.


//============================================================================
unicode
//============================================================================

character type sizes - look in small_progs/type_limits.cpp


//============================================================================
traits
//============================================================================

https://erdani.com/publications/traits.html
In short, traits are important because they allow you to make compile-time decisions based on types, 
much as you would make runtime decisions based on values. 
Better still, by adding the proverbial "extra level of indirection" that solves many software engineering problems, 
traits let you take the type decisions out of the immediate context where they are made. 
This makes the resulting code cleaner, more readable, and easier to maintain. 
If you apply traits correctly, you get these advantages without paying the cost in performance, safety, or coupling that other solutions might exact. 

sample implementation:
small_progs/type_limits.cpp

https://erdani.com/publications/traits.html

traits are important because they allow you to make compile-time decisions based on types, 
much as you would make runtime decisions based on values.

Traits rely on explicit template specialization to pull out type-related variations from code, and to wrap them under a uniform interface.

A traits template is a template class, possibly explicitly specialized, 
that provides a uniform symbolic interface over a coherent set of design choices that vary from one type to another.


//============================================================================
multimap multiset
//============================================================================

learn_algorithms/codeforces_archive/659b_multimap.cpp
learn_algorithms/codeforces_archive/659b_multiset.cpp
small_progs/learn_multimap_multiset.cpp

multimap<string,string> mm;

//insert
mm.insert(make_pair("key1","val11"));
mm.emplace("key1","val12");

//iterate
for(auto &p : mm)
{
	cout <<p.first<<" "<<p.second<<endl;	    	
}
cout <<mm.begin()->first<<endl;   


//get elements by key (p is pair - first, second)
auto p = mm.equal_range(key); 
    
for(auto it=p.first;it!=p.second;++it)
{
	cout <<it->second<<endl;	
}

//get number of found items:
cout <<"number of items: "<<distance(p.first,p.second)<<endl;

//erase
int removedCount = mm.erase(key); //Return value Number of elements removed.
auto p2 = mm.equal_range(key);
mm.erase(p2.first,p2.second); //Return value  Iterator following the last removed element.
auto p2 = mm.equal_range(key);
mm.erase(p2.first); //Return value  Iterator following the last removed element.

//number of elements with specific key:
mm.count(key);

//number of elements
mm.size();


//============================================================================
priority_queue
//============================================================================

default container - class Container = vector<T>

const_reference top() const;
void pop();
void push (const value_type& val);
template <class... Args> void emplace (Args&&... args);

    //=================== priority queue ==========================    
    priority_queue<string> q;
    q.push("hello");
    q.emplace("world");
    q.push("program");
    cout <<q.top()<<" "<<q.top()<<q.size()<<endl;
    q.pop();
    cout <<q.top()<<" "<<q.top()<<q.size()<<endl;    
    //=================== priority queue ==========================


//============================================================================    
const pointer and pointer to const    
//============================================================================    

Если слово const перед звездочкой (не важно перед или после int) - то
это изменяемый указатель на константные данные.
Сам указатель константный только если const стоит после звездочки.

int const * - pointer to const int
int * const - const pointer to int
int const * const - const pointer to const int

Now the first const can be on either side of the type so:
    const int * == int const *
    const int * const == int const * const


//============================================================================
posix processes
//============================================================================

show all processes on system:
ps -e

send program SIGTERM signal
kill
kill (child_pid, SIGTERM);

Получить номера сигналов:
/bin/kill --table
 1 HUP      2 INT      3 QUIT     4 ILL      5 TRAP     6 ABRT     7 BUS
 8 FPE      9 KILL    10 USR1    11 SEGV    12 USR2    13 PIPE    14 ALRM
15 TERM    16 STKFLT  17 CHLD    18 CONT    19 STOP    20 TSTP    21 TTIN
22 TTOU    23 URG     24 XCPU    25 XFSZ    26 VTALRM  27 PROF    28 WINCH
29 POLL    30 PWR     31 SYS     

//------------------------------------------------

system creates a subprocess running the standard Bourne shell (/bin/sh)
and hands the command to that shell for execution
return_value = system ("ls -l /");

//------------------------------------------------

fork:
learn_system.cpp

pid_t result=fork();
if(result==0)
{
	cout <<"child"<<endl;
}
else if(result>0)
{
	cout <<"parent"<<endl;	
}
else
{
	cout <<"error!"<<endl;    
}

//------------------------------------------------

exec:
int result = execlp("echo","echo","hello!","world!",NULL);
cout <<"exec failed! "<<result<<endl;

//------------------------------------------------

nice - set process priority
program and function
больше nice - меньше priority
Niceness values range from -20 (most favorable to the process) to 19 (least favorable to the process).
nice()  adds  inc to the nice value for the calling process.  (A higher nice value means a low priority.)  Only the
superuser may specify a negative increment, or priority increase.

int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int prio);

//------------------------------------------------

signals:
you should avoid performing any I/O operations or calling most library
and system functions from signal handlers. In
most cases, this consists simply of recording the fact that a signal occurred.The main
program then checks periodically whether a signal has occurred and reacts accordingly.

The SIGTERM
signal asks a process to terminate; the process may
ignore the request by masking or ignoring the signal.
The SIGKILL signal always kills the process
immediately because the process may not mask or ignore  SIGKILL

signal(SIGINT,sig_int_handler);
void sig_int_handler(int i)
{ 
    printf("sig int handler\r\n");
    exit(-1);
}
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

sig_atomic_t sigusr1_count = 0;
void handler (int signal_number)
{
	++sigusr1_count;
}
struct sigaction sa;
memset (&sa, 0, sizeof (sa));
sa.sa_handler = &handler;
sigaction (SIGUSR1, &sa, NULL);
printf (“SIGUSR1 was raised %d times\n”, sigusr1_count);

ожидать завершения ребенка:
int child_status;
wait (&child_status);
if (WIFEXITED (child_status))
	printf (“the child process exited normally, with exit code %d\n”,WEXITSTATUS (child_status));
else
	printf (“the child process exited abnormally\n”);

Также waitpid, waitid.

A zombie process is a process that has terminated but has not been cleaned up yet (wait не была вызвана).

When a program exits, its children are inherited by a special process, the init program, which
always runs with process ID of 1 (it ’s the first process started when Linux boots).The init
process automatically cleans up any zombie child processes that it inherits.

wait3 or wait4 have parameter not to wait, immediately return if no child events exist.
When a child process terminates, Linux sends the parent process the SIGCHLD signal.
an easy way to clean up child processes is by handling SIGCHLD


//============================================================================
posix threads
//============================================================================
//нужно добавлять библиотеку:
g++ -lpthread

pthread_create
pthread_join(thread_handle,(void**)&thread_result);

The pthread_self function returns the thread ID of the thread in which it is called

A joinable thread, like a process, is not automatically cleaned up by GNU/Linux when it terminates. 
Instead, the thread’s exit
state hangs around in the system (kind of like a zombie process) until another thread
calls pthread_join to obtain its return value. Only then are its resources released.

A detached thread, in contrast, is cleaned up automatically when it terminates. 

Create detached thread:
pthread_attr_t attr;
pthread_attr_init (&attr);
pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);	
pthread_create (&thread, &attr, &thread_function, NULL);
pthread_attr_destroy (&attr);

Set thread to detached mode after creation: call pthread_detach

A thread may be in one of three states with regard to thread cancellation.

The thread may be asynchronously cancelable
The thread may be canceled at any point in its execution.

The thread may be synchronously cancelable
The thread may be canceled, but not at just any point in its execution. Instead, cancellation requests are queued, and
the thread is canceled only when it reaches specific points in its execution.

A thread may be uncancelable
Attempts to cancel the thread are quietly ignored.

When initially created, a thread is synchronously cancelable.

Функция для установки cancel state:
pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, NULL);


Thread specific data:
pthread_key_create
pthread_getspecific
pthread_setspecific

Thread cleanup handlers - функции, которые вызываются при завершении потока.
pthread_cleanup_push
pthread_cleanup_pop


Мютексы:
pthread_mutex_t mutex;
pthread_mutex_init (&mutex, NULL);
pthread_mutex_lock (&job_queue_mutex);
pthread_mutex_unlock (&job_queue_mutex);

A simple type of deadlock may occur when the same thread attempts to lock a mutex twice in a row.
Есть при типа поведения:
* Locking a fast mutex (the default kind) will cause a deadlock to occur. 
* Locking a recursive mutex does not cause a deadlock.
* GNU/Linux will detect and flag a double lock on an error-checking mutex that
would otherwise cause a deadlock.The second consecutive call to pthread_mutex_lock returns the failure code EDEADLK.

By default, a GNU/Linux mutex is of the fast kind. Другие получаются так:
pthread_mutexattr_t attr;
pthread_mutex_t mutex;
pthread_mutexattr_init (&attr);
pthread_mutexattr_setkind_np (&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
pthread_mutex_init (&mutex, &attr);
pthread_mutexattr_destroy (&attr);

Nonblocking Mutex Tests:
pthread_mutex_trylock


Semaphores for Threads
sem_init
sem_post
sem_wait

Conditional variable
1. The loop in thread_function locks the mutex and reads the flag value.
2.  If the flag is set, it unlocks the mutex and executes the work function.
3.  If the flag is not set, it atomically unlocks the mutex and waits on the condition variable.
The critical feature here is in step 3, in which GNU/Linux allows you to unlock the
mutex and wait on the condition variable atomically, without the possibility of
another thread intervening.

pthread_cond_init initializes a condition variable.
pthread_cond_signal signals a condition variable. A single thread that is blocked on the condition variable will be unblocked. 
pthread_cond_broadcast unblocks all threads that are blocked on the condition variable, instead of just one.
pthread_cond_wait blocks the calling thread until the condition variable is signaled.

Whenever your program performs an action that may change the sense of the condition you’re protecting with the condition variable, it should perform these steps: 
1.  Lock the mutex accompanying the condition variable.
2.  Take the action that may change the sense of the condition (in our example, set the flag).
3.  Signal or broadcast the condition variable, depending on the desired behavior.
4.  Unlock the mutex accompanying the condition variable.

Wait for conditional variable:
pthread_mutex_lock (&thread_flag_mutex);
while (!thread_flag)
{
    pthread_cond_wait (&thread_flag_cv, &thread_flag_mutex);
}
pthread_mutex_unlock (&thread_flag_mutex);

The implementation of POSIX threads on GNU/Linux differs from the thread imple-
mentation on many other UNIX-like systems in an important way: on GNU/Linux,
threads are implemented as processes.Whenever you call pthread_create to create a
new thread, Linux creates a new process that runs that thread. However, this process is
not the same as a process you would create with fork; in particular, it shares the same
address space and resources as the original process rather than receiving copies.

Within a multithreaded program, it is possible for one thread to send a signal
specifically to another thread. Use the pthread_kill function to do this. Its first parameter is a thread ID, and its second parameter is a signal number.


//============================================================================
posix ipc
//============================================================================

//----------------------------------------

* Shared memory 
permits processes to communicate by simply reading and 
writing to a specified memory location.

* Process Semaphores System V

* Process Semaphores Posix

* Mapped memory 
is similar to shared memory, except that it is associated with a
file in the filesystem. 

* Pipes
permit sequential communication from one process to a related process.

* FIFO (Named Pipes)
are similar to pipes, except that unrelated processes can communicate
because the pipe is given a name in the filesystem.

* Sockets (PF_LOCAL and PF_UNIX)
support communication between unrelated processes even on different computers.

//----------------------------------------


Shared memory

Shared memory is the fastest form of interprocess communication because all
processes share the same piece of memory. Access to this shared memory is as fast as
accessing a process’s nonshared memory, and it does not require a system call or entry to the kernel. 

shmget - allocate shared memory.
int segment_id = shmget (shm_key, getpagesize (),IPC_CREAT |S_IRUSR |S_IWUSER);

shmat - attach shared memory.
shmdt - detach shared memory.
shmctl - get and set shared memory params.

ipcs command provides information on interprocess communication facilities


//----------------------------------------

Process Semaphores System V

process semaphores or sometimes System V (System Five) semaphores. 

//allocate semaphore
semget (key, 1, sem_flags);

//deallocate semaphore
semctl (semid, 1, IPC_RMID, ignored_argument);

To initialize a semaphore, use semctl with zero as the second argument and SETALL as the third argument.

semop - wait and post operations.

//----------------------------------------

Process Semaphores Posix

sem_open
sem_wait
sem_post
sem_getvalue
sem_close
sem_unlink

//----------------------------------------

Memory Mapped files
mmap - map file.

int fd = open (argv[1], O_RDWR |O_CREAT, S_IRUSR |S_IWUSR);
file_memory = mmap (0, FILE_LENGTH, PROT_WRITE, MAP_SHARED, fd, 0);
close (fd);

//----------------------------------------

Pipes

int pipe_fds[2];
int read_fd;
int write_fd;
pipe (pipe_fds);
read_fd = pipe_fds[0];
write_fd = pipe_fds[1];

//Connect the read end of the pipe to standard input 
dup2 (fds[0], STDIN_FILENO);

popen / pclose - run child process and create pipe to it
FILE* stream = popen (“sort”, “w”); //sort - name of unix program.
fprintf (stream, “This is a test.\n”);
fprintf (stream, “Hello, world.\n”);
pclose (stream);

The call to popencreates a child process executing the sortcommand, replacing callsto pipe,fork,dup2, and execlp.
The second argument, “w”, indicates that this processwants to write to the child process

//----------------------------------------

FIFO (named pipes)

A first-in, first-out (FIFO) file is a pipe that has a name in the filesystem.

To make fifo in bash: mkfifo /tmp/somefifoname 

in program - mkfifo function.

Access a FIFO just like an ordinary file

A FIFO can have multiple readers or multiple writers. Bytes from each writer are
written atomically up to a maximum size of PIPE_BUF (4KB on Linux). Chunks from
simultaneous writers can be interleaved. Similar rules apply to simultaneous reads.

//----------------------------------------

Sockets
Sockets connecting processes on the same computer can use the local namespace represented by the synonyms 
PF_LOCAL and PF_UNIX.These are called local sockets or UNIX-domain sockets.

PF_LOCAL, PF_UNIX создает файл в файловой системе. После окончания работы нужно вызвать unlink(file_name)

socket_fd = socket (PF_LOCAL, SOCK_STREAM, 0);

socketpair - создать пару сокетов для связанных процессов (только PF_LOCAL).


//============================================================================
stl and thread safety
//============================================================================

http://en.cppreference.com/w/cpp/container#Thread_safety

* All container functions can be called concurrently by different threads on different containers. 
* All const member functions can be called concurrently by different threads on the same container. 
In addition, the member functions begin(), end(), rbegin(), rend(), front(), back(), data(), find(), lower_bound(), upper_bound(), equal_range(), at(), and, 
except in associative containers, operator[], behave as const for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). 
More generally, the C++ standard library functions do not modify objects unless those objects are accessible, 
directly or indirectly, via the function's non-const arguments
* Different elements in the same container can be modified concurrently by different threads, except for the elements of std::vector<bool> 
* Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, 
and may be executed concurrently with operations on other iterators on the same container, 
with the const member functions, or reads from the elements. 
Container operations that invalidate any iterators modify the container and cannot be executed concurrently 
with any operations on existing iterators even if those iterators are not invalidated. 
* Elements of the same container can be modified concurrently with those member functions that are not specified to access these elements.
* In any case, container operations (as well as algorithms, or any other C++ standard library functions) 
may be parallelized internally as long as this does not change the user-visible results. 


//============================================================================
C++ 11 threads
//============================================================================

http://en.cppreference.com/w/cpp/thread

thread
mutex
condition_variable
futures

//-----------------------------------------------------------------

mutex:
mutex
timed_mutex
recursive_mutex
recursive_timed_mutex
shared_mutex (c++17)
shared_timed_mutex (c++14)

mutex methods:
lock, try_lock, unlock

shared_mutex (shared_mutex has two levels of access:
    shared - several threads can share ownership of the same mutex. 
    exclusive - only one thread can own the mutex. (one writer - multiple readers)):
lock, try_lock, unlock
lock_shared, try_lock_shared, unlock_shared


scope locks:
lock_guard
unique_lock
shared_lock

{
    std::lock_guard<std::mutex> lock(g_i_mutex);
}    

lock, try_lock - lock algorithms, avoid deadlocks.
std::lock(e1.m, e2.m);
std::lock_guard<std::mutex> lk1(e1.m, std::adopt_lock);
std::lock_guard<std::mutex> lk2(e2.m, std::adopt_lock);


Difference lock_guard - unique_lock:
The difference is that you can lock and unlock a std::unique_lock. std::lock_guard will be locked only once on construction and unlocked on destruction.


call_once - Executes the Callable object f exactly once, even if called from several threads. 


//-----------------------------------------------------------------

conditional_variable:

void ThreadPool::runTask(ThreadFunction fun, void *userData)
{
    {
        unique_lock<mutex> lock(mutexTasks);
    
        tasks.push(ThreadPoolTask(fun,userData));
    }

    cvTasks.notify_one();
}
...........................

{
    unique_lock<mutex> lock(mutexTasks);

    //проверка делается под mutex-ом, так что не может быть такого, что
    //проверили условие, потом оно изменилось, а мы попали в wait
    while(tasks.empty())
    {
        cvTasks.wait(lock);                
    }
}

td::condition_variable works only with std::unique_lock<std::mutex>
std::condition_variable_any provides a condition variable that works with any BasicLockable object. 

notify_all_at_thread_exit provides a mechanism to notify other threads that a given thread has completely finished:
void notify_all_at_thread_exit( std::condition_variable& cond,
                                std::unique_lock<std::mutex> lk );
            
Do I have to aquire lock before calling condition_variable.notify_one()?
You do not need to be holding a lock when calling condition_variable::notify_one(), 
but it's not wrong in the sense that it's still well defined behavior and not an error.
However, it might be a "pessimization" since whatever waiting thread is made runnable (if any) 
will immediately try to acquire the lock that the notifying thread holds.
                                
//-----------------------------------------------------------------


//============================================================================
c++11 futures
//============================================================================
small_progs/futures.cpp

void work1(int x, int y, int z, promise<int> result)
{
    result.set_value(x+y+z);
}

void test1()
{
    promise<int> myPromise1;
    future<int> myFuture1 = myPromise1.get_future();
    thread myThread1(work1,1,2,3,move(myPromise1));
    
    myFuture1.wait();
    int result = myFuture1.get();
    
    debug2("%d",result);
    
    myThread1.join();    
}

The promise is the "push" end of the promise-future communication channel: 
the operation that stores a value in the shared state, 
the successful return from any function that is waiting on the shared state (such as std::future::get).


promise-future with exception:
void work2(int x, int y, int z, promise<int> result)
{
    result.set_exception(make_exception_ptr(invalid_argument("works2!")));
}

void test2()
{    
    promise<int> myPromise1;
    future<int> myFuture1 = myPromise1.get_future();
    thread myThread1(work2,1,2,3,move(myPromise1));
    
    myFuture1.wait();

    try{
        int result = myFuture1.get();
        debug2("%d",result);
    }catch(invalid_argument ex){
        cout <<"catch in main thread: "<<ex.what()<<endl;
    }    

    myThread1.join();
}

promise - объект, который передается в поток для возврата значения.
future - объект, который используется в главном потоке для получения значения.

//-----------------------------------------------------------------

http://stackoverflow.com/questions/18143661/what-is-the-difference-between-packaged-task-and-async

async and ~future Herb Sutter:
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf

std::futures from std::async aren't special!  Scott Meyers
http://scottmeyers.blogspot.ru/2013/03/stdfutures-from-stdasync-arent-special.html


int work3(int x, int y, int z)
{
    return x+y+z;
}

void test_packaged_task1()
{
    packaged_task<int()> pack_task(bind(work3,1,2,3));
    future<int> future1 = pack_task.get_future();
    pack_task();
    int result = future1.get();
    debug2("packaged task: %d",result);   
}

get_future can be called only once for each packaged_task. 

//-----------------------------------------------------------------

shared_future - можно копировать, все копии связаны с одним результатом. 
Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a shared_future object. 

//-----------------------------------------------------------------

std::async - template function async runs the function f asynchronously (potentially in a separate thread which may be part of a thread pool) 
and returns a std::future that will eventually hold the result of that function call. 

Simply spoken a std::packaged_task is a std::function linked to a std::future and std::async wraps and calls a std::packaged_task

//============================================================================
sockets
//============================================================================

Вызовы клиент:
socket
gethostbyname или getaddrinfo
connect
send / write
recv / read
close

Вызовы сервер:
socket
bind //связывает сокет с конкретным адресом. Когда сокет создается при помощи socket(), он ассоциируется с некоторым семейством адресов, но не с конкретным адресом.
listen
while
{
    client_socket = accept
    recv
    send
    close
}
close


udp socket client:
socket
gethostbyname
while
{
    sendto
    recvfrom
}
close

udp socket server:
socket
bind
while
{
    recvfrom //returns client address
    sendto   //we can send back to client address
}    
close

//============================================================================
tcp/ip levels
//============================================================================

Application layer (Прикладной)     HTTP, RTSP, FTP, DNS
Transport layer   (Транспортный)   TCP, UDP
Internet layer    (Сетевой)        IP, ICMP
Link layer        (Канальный)      Ethernet, Wifi


Сетевая модель OSI (open systems interconnection basic reference model):
----- Host layers -----
Прикладной (application)
Представительский (представления) (presentation)
Сеансовый (session)
Транспортный (transport)

----- Media Layers -----
Сетевой (network)
Канальный (data link)
Физический (physical)


Tcp/Ip - OSI - соответствие:
TCP/IP        OSI

Application - application, presentation, session
transport   - transport
network     - network
Link layer  - link, physical


//============================================================================
ICMP socket
//============================================================================
/mnt/programs/programs/programs2/mylib/icmp_echo.c

ping:
socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)
sendto(sock,(void*)&opckt,SOF_OPCKT,0,(struct sockaddr*)&si,sizeof(struct sockaddr_in)
read(fd,buf,buf_size)
close(sock);


//============================================================================
poll / select
//============================================================================
http_server.cpp

select:

fd_set select_read_fds;
FD_ZERO(&select_read_fds);
FD_SET(sockfd, &select_read_fds);

int selectResult = select( max_select_fd + 1 , &select_read_fds , NULL , NULL , NULL);

if(selectResult>0)
{    
    if (FD_ISSET(sockfd, &select_read_fds)) 
    {
        new_socket = accept(sockfd, (struct sockaddr *)&address, (socklen_t*)&addrlen)        
    }
    
    if(FD_ISSET(client_socket[i],&select_read_fds))
    {
        int numBytes = recv(client_socket_fd,buf,bufSize-1,0);
    }    
}


poll:

    const int max_poll_fds=1000;
    struct pollfd poll_fds[max_poll_fds];
    int poll_fds_size=1;
    
    poll_fds[0].fd=sockfd;
    poll_fds[0].events=POLLIN;

    int result = poll(poll_fds,poll_fds_size,5000);
    
    if(result>0)
    {
            for(int i=0;i<poll_fds_size;i++)
            {
                if(poll_fds[i].revents & POLLIN)
                {
                        int client_socket_fd=poll_fds[i].fd;                        
                        int numBytes = recv(client_socket_fd,buf,bufSize-1,0);
                        
                        if(numBytes==0)
                        {
                            close(client_socket_fd);
                            poll_fds[i].fd=-1;
                        }                        
                }
            }
    }

//============================================================================
design pattern
//============================================================================
повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

https://en.wikipedia.org/wiki/Design_Patterns

Creational
Abstract factory - groups object factories that have a common theme
interface IButton
{
    void Paint();
}
interface IGUIFactory
{
    IButton CreateButton();
}
class WinFactory : IGUIFactory
{
    public IButton CreateButton()
    {
        return new WinButton();
    }
}

class OSXFactory : IGUIFactory
{
    public IButton CreateButton()
    {
        return new OSXButton();
    }
}
IGUIFactory factory;
switch (appearance)
{
    case Appearance.Win:
        factory = new WinFactory();
        break;
    case Appearance.OSX:
        factory = new OSXFactory();
        break;
    default:
        throw new System.NotImplementedException();
}
var button = factory.CreateButton();

//---------------------------------------------------------

Singleton - restricts object creation for a class to only one instance.

//---------------------------------------------------------

Factory method -  creating objects by calling a factory method—either specified in an interface and implemented by child classes, 
or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor.
public class MagicMazeGame extends MazeGame {
    @Override
    protected Room makeRoom() {
        return new MagicRoom(); 
    }
}
public class OrdinaryMazeGame extends MazeGame {
    @Override
    protected Room makeRoom() {
        return new OrdinaryRoom(); 
    }
}

//---------------------------------------------------------

Prototype pattern
It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects.
public abstract class Prototype
{
    // normal implementation
    public abstract Prototype Clone();
}
public class ConcretePrototype1 : Prototype
{
    public override Prototype Clone()
    {
        return (Prototype)this.MemberwiseClone(); // Clones the concrete class.
    }
}
public class ConcretePrototype2 : Prototype
{
    public override Prototype Clone()
    {
        return (Prototype)this.MemberwiseClone(); // Clones the concrete class.
    }
}

//---------------------------------------------------------




//============================================================================
Разное
//============================================================================
vector<bool> - специализация, использует один бит для значения. Лучше не использовать.

Boost.Lockfree:
The C++ exception handling does not give any guarantees about its real-time behavior. We therefore do not encourage the use of exceptions and exception handling in lock-free code. 

Lock free containers: Boost.Lockfree
boost::lockfree::queue
boost::lockfree::stack
boost::lockfree::spsc_queue


c++ string formatters:
http://www.gotw.ca/publications/mill19.htm

